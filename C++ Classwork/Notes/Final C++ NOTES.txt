Introduction to C++

C++ was invented by Bjarne Stroustrup in 1979 at Bell lab.
initially he called this lang as, c with classes,later in 1983 the name was changed to c++.


==>C++ is a general purpose/multipurpose,high level,compiler based and object oriented programming language.

==>What is general purpose?
purpose means usage
by using c++ we can design different types of s/ws


Types of programming language
1. Low-level programming language
Low-level language is machine-dependent (0s and 1s) programming language. The processor runs low- level programs directly without the need of a compiler or interpreter, so the programs written in low-level language can be run very fast.


2. High-level programming language (HLL) -It is designed for developing user-friendly software programs and websites.
This programming language requires a compiler or interpreter to translate the program into machine language (execute the program).
Example: Python, Java, JavaScript, PHP, C#, C,C++, etc.
A high-level language is further divided into two parts -
	a)Procedural Oriented programming language
	b)Object-Oriented Programming language


ques)which s/w application we can create using c++?
==>using c++ , we can design operating system(dos,window,unix)
==>using c++,we can design editors(notepad,wordpad,editplus)
==>using c++,we can designcommercial application(related to money like (bank program,hotel managment program,supermarket program)
In supermarket,bill should be generated,billing program is designed using c++.Bank transactions application is designed using c++.
==>using c++,we are also able to design database(oracle is designed by c and c++)
==>using c++,we can also design translators(compiler,interpreter,assembler)
compiler and interpreter are used to convert high level lang to machine code.
assembler is used to convert low level lang to machine code.
In c++ we are using compiler as a translator,thats why c++ is called as compiler based programming lang.
==>using c++,we can design PC and mobile games. ex:snake game,mario etc.
=========================================================
Software is a collection of programs. /it is a digitized automated process
program is a set of instructions

===============================================================================
Object oriented programming
==>C++ is an extension of C programming
==>learn limitation and adv of c, how it is solved in c++?

Function oriented programming lang/Procedural Language:

==>Total program is divided into small programs called as functions. 
Advantages are:
easy to identify errors
modularity
reusability(write once use many times)

Function is a small program which is ued to do a particular job.


Entire c program is collection of functions thats why c++ is called as function oriented programming lang.
procedural lang means all data stored at one place
all data accessible to all function
data is not secured
===============================================

problem with function
==>when program is big ,when data is global then to identify  which variable is accesed by which function  is 
very difficult.problem is when data is global ,any function can access it . so data is not secured because data is freely moving around the function.
==>In c programming lang, data and function is seperately stored and global data is accessible to every function.
but in oop they bind variable and function in single unit called as object. when it make private it is accessible only within that funtion.
==>it is difficult to map real world entities into system design.it is difficult to bind data to the functionality of the system because its functionality is considered seperately
==>debugging a structured program is difficult and time consuming process.since data is shared over the entire program,different functions may be accessing it.to exactly find whuch function is causing the error is not easy.



Ex:
In a class several students are there,every student is having its own data.one student data doesnt belong to another student data.

stu1 obj
id ,name,fees----->attributes
To access this variables we have to use function,this function is able to access only student1 data
stu2 obj
id ,name,fees----->attributes,to access this variables we have to use function,this function is able to access only student2 data

i.e  data is seperated into no of blocks called object called as object1,object 2.
object1 contains first student data,object2 contains 2nd student data.
total program is divided into several objects. thatwhy c++ is called as object oriented programming structure.

ex:supemarket bill 
ITEM		QTY		PRICE		AMOUNT
A			10		10			100
B			20		20			200

object1 contains A item details only. object2 contains B item details only.

in oop function and data both are link with one another.obj is having variables,these variables are accessible only within the fun associated with that object called as data hiding.
===================================================================================
object oriented programming features

1)class-->extension of c structure
structure is collection of  heterogenous datatype. structure allows us to store different types of variables at one place under one name.due to structure ,it is very easy to construct object oriented programming.
In oop will going to use class but that class derived/extension of c structure.

==>we can able to declared both primitive and derived datatype at one place using structure.
ex:
I want to store student related data at one place ..
 struct stu
{
int id;primitaive
int marks[6];//derived;
};
structure is constructed based on the user requirement  thats  why structure is called as user defined datatyes...

 struct stu
{
int id;primitaive
int marks[6];//derived;
}s1,s2;//structure variable stored on stack.

here  s1 stores 1 student data which is called as 1 object,now it is called object oriented .
structure are the foundations to create class in c++.

********disadvantage with structure*********
In c lang structure data is by default public.structure can be accessed from anywhere within the program. 
now to avoid this they have introduced class.

In c++ also, we are having structure.

Whats the difference between structure in C and structure in C++?
In C ,inside the structure we can declare only variables(member structure) . while in C++,we can declare member structure +member function

**In c++ also structure data is public.that means anyone can access data from anywhere,not secured.
that why they have introduced class in c++.
==========================================
In c++,the private data shld be accessed only with the member function of the same class.
struct  student
{
private/protected/public   datatype
datamembers
memberfunctions;
};
class student
{
private/protected/public   datatype
datamembers
memberfunctions;
};
using c++ structure ,we cannot define complex programs.But it is possible with the class concepts.

2)class uses the concept of inheritance but structure in c++ never uses the concept of inheritance

3)if we dont specify access specifier to a data member of a class by default all the members become private
3)in c++ structure by default all the members are public. by default structure data is public,class data is private. 
====================================================================================
when it is private what will happen?
class student
{
int id;//data members
public:
void get()
{
cout<<id;
}
}
get() is the member of the class thats why it is called as member function.
with the help of member function of a class we can access private data of a class.this data cannot be accessible from outside the class called as
data hiding. mostly achieve using private access specifier.
data hiding means insulating the data from external access. outsiders cannot access the data.only member function can access the data. 
ex:mobile ph

**class is a collection of data members and member function both are associated together into a single unit called as class is called encapsulation
encapsulation is a process of binding the data under member function together into a single unit  called class.

class provides data hiding,encapsulation(binding of data and function into a single unit called as class)

====================================================> In class, to access the data member first memory should be allocated,for this the object shld be created.

OBJECT

==>In structure,structure variable should be created to access the structure members.
==>In class,class variables are called as object.
object means it is a variable of type class.

class stu
{
};
stu s;//object  (memory allocation takes place)
==>this obj is created from this class, that why  class is called as blueprint(original copy) to construct the object(xerox copy). thatswhy
to create object we need class,thats  why class is a blueprint and object is the instance of the class.

==>object is the physical representation of a class.when object is created then only memory allocation takes place. class never allocates memory i.e logical representation.
==================================================
Difference between C structure and C ++ structure

1)collection of variables                     collection of variables 										and function
2)structure members are public       structure members are 								private,protected,public
-------------------------------------------------------------------------------
similarities between  C++ structure and class
1)userdefined                          				  userdefined
2)collection of variables & functions   		collection of 									variables & functions
3)members are private,protected,public		members are 								private,protected,public
-------------------------------------------------------------------		
Differences between  C	++ structure and class
1)by default members are public 		by default members 										are private
2) structure cannot be inherited		class can be inherited
3)used to build simple program			uses to build 							complex program,big project
not used in bank prog,reservation
============================================================================
class:
1)it is a userdefined datatypes because we r constructing a class based on primitive and derived datatype as per user requrimemt

2)collection of datamembers and member functions
3)it is a container because it contains members.
4)class provides the concept of encapsulation(binding of data memebrs and member function in a single unit),provides the concept of data hiding with private access specifier.
5)class is a blueprint to constructs the objects i.e it is a plan before constructing objectts
paper plan(class)--------->  real building(object)
6)class is a logical copy to create objects thats why class never occupies memory.

syntax:
class classname//class is keyword
{
access specifier://it specifies how it is going to access in our program
datamember;
member function;
};


1)private: whenever datamembers and membar functions are private, they cannot be accessed directly using objects.
class A
{
int a; //int a=100;//not allowed ,direct initilization not allowed
void get()
{
a=100;
cout<<a;//allowed
}//private data can be accessed within member function of same class
}
void main()
{
	obj;
obj.a=100;//not allowed whenever datamembers and member functions are private cannot be accessed directly using objects.
obj.get();//not allowed whenever datamembers and member functions are private cannot be accessed directly using objects.
   //. is called membership operator
} 


Therefore it is better to use one public member
class A
{
 int a; //int a=100;//not allowed ,direct initilization not allowed
public void get()
{
a=100;
cout<<a;//allowed
}
}
void main()
{
	obj;
obj.a=100;//not allowed whenever datamembers and member functions are private cannot be accessed directly using objects.
obj.get();// allowed 
   //. is called membership operator
} 

keypoint: when all the members are private,it is useless because to access the members,we have to declared object,where the object is generally declred and where members are called i.e from the main(),and main() is outside the class.thumb rule is private members are not visible outside the class.
called as datahiding...declared one public()

========================================================================================
class student
{
private:
int id;
char name;
float fee;
public:
void get()//inline function
{
cout<<"enter id and fee";

cin>>id>>fee;
cout<<"id = "<<id<<endl;
}
};
void main()
{

}




class student
{
private:
int id;
char name;
float fee;
public:
void get();
};
void student::get()//not inline ::scope operator
{
cout<<"enter id and fee";

cin>>id>>fee;
cout<<"id = "<<id<<endl;
cout<<"fee = "<<fee<<endl;
}
 
void main()
{
student stu;//mem allocated
stu.get();

}

=========================================================================
OBJECT
To access class members,we should define objects because when class is declared memory is not allocated,when object is defined then only memory is allocated.

ex: int a,b;
int is logical copy occupies no memory
a,b is physical copy ,memory gets allocated

ex:student stu;
stu.get();
stu.put();
thru object we can access class members...

Object is :
1) a variable of type class.
2)an instance/xerox copy of a class
3)it is physical representation of a class.
==========================================================================
Difference between procedural programming and object-oriented programming

1)In procedural programming, the program is divided into small parts called functions.	
In object-oriented programming, the program is divided into small parts called objects.

2)It is less secure than OOPs. 
Data hiding is possible in object-oriented programming . So, it is more secure than procedural programming.

3)There is no access specifier in procedural programming.
  Object-oriented programming has access specifiers like private, public, protected, etc.

4)In procedural programming, data moves freely within the system from one function to another.	
In OOP, objects can move and communicate with each other via member functions.

5)There is no code reusability present in procedural programming.
	It offers code reusability by using the feature of inheritance.
===============================================================================================
C++ Features

Popular
C++ can be the base language for many other programming languages that supports the feature of object-oriented programming. 

 Compiler based
C++ is a compiler-based programming language, which means no C++ program can be executed without compilation. C++ compiler is easily available, and it requires very little space for storage. First, we need to compile our program using a compiler, and then we can execute our program.

Machine Independent

Platform:
Platform consists of processor/cpu and operating system.

Platform Dependent ?
The code which can only be run on same platform on which it was compiled. Compiled code cannot run on any other platforms.such language is called as platform dependent .
ex: C,C++

Here, same machine code which is compiled on windows,cannot be run on Linux or MAC OS.
To run the code on MAC OS ,first we will have to compile in MAC OS.
so such languages do not support code portability.


A C++ executable is not platform-independent (compiled programs on Linux won’t run on Windows), however, they are machine-independent.  Suppose you have written a piece of code that can run on Linux/Windows/Mac OSx which makes the C++ Machine Independent but the executable file of the C++ cannot run on different operating systems.



Rich Library
C++ provides a lot of inbuilt functions that make the development fast. Following are the libraries used in C++ programming are:

<iostream>
<cmath>
<cstdlib>
<fstream>

 Memory Management
C++ provides very efficient management techniques. The various memory management operators help save the memory and improve the program's efficiency. These operators allocate and deallocate memory at run time. Some common memory management operators available C++ are new, delete etc.

Object-Oriented
In C++, object-oriented concepts like data hiding, encapsulation, and data abstraction can easily be implemented using keyword class, private, public, and protected access specifiers. Object-oriented makes development and maintenance easier.

====================================================================
Difference between C and C++

C was developed by Dennis Ritchie between the year 1969 and 1973 at AT&T Bell Labs.	
C++ was developed by Bjarne Stroustrup in 1979.

C does no support polymorphism, encapsulation, and inheritance which means that C does not support object oriented programming.	
C++ supports polymorphism, encapsulation, and inheritance because it is an object oriented programming language.

C supports procedural programming.	 
C++ supports object oriented programming paradigms.

Data and functions are separated in C because it is a procedural programming language.	
Data and functions are encapsulated together in form of an object in C++.

C does not support data hiding so not secured.	
C++ supports data hiding with the help of private access specifier,secured.

Functions in C are not defined inside structures.	
Functions can be used inside a structure in C++.

C does not support inheritance.	
C++ supports inheritance.

Instead of focusing on data, C focuses on functions.	
C++ focuses on data instead of focusing on method or procedure.

C provides malloc() and calloc() functions for dynamic memory allocation, and free() for memory de-allocation.	
C++ provides new operator for memory allocation and delete operator for memory de-allocation.

Direct support for exception handling is not supported by C.	
Exception handling is supported by C++.

scanf() and printf() functions are used for input/output in C.	
cin and cout are used for input/output in C++.

C structures don’t have access modifiers.	
C ++ structures have access modifiers.

C does not support reference variables.
C++ supports reference variables.
========================================================================
Types of Variables
There are three types of variables based on the scope of variables in C++
Local Variables
Instance Variables
Static Variables

local variable
the variable declared within the parenthesis of any function or any block is 
called as local variable.
These variables are created when entered into the block or the function is called and destroyed after exiting from the block or when the call returns from the function.
The scope of these variables exists only within the block in which the variable is declared. i.e. we can access this variable only within that block.
1)local variable cannot be declared globally 
2)Initialization of Local Variable is Mandatory.
3)scope and lifetime is within the block/within the function
4)storage is stack section

lifetime means how long the variable exists in the memory
scope means how long the variable or value of that variable can be accessed
in local variable lifetime depends on scope of variable

#include<stdio.h>
int main()
{
	int a=10;
	 printf("%d",a);//10
	 {
		 int a=100;
		 printf("%d",a);//100
	 }
	 printf("%d",a);//10
}

global variable
Declaring global variables: Global variables are usually declared outside of all of the functions and blocks, at the top of the program. They can be accessed from any portion of the program.
variable declared outside the function/block is called as global variable
initial value is 0
storage is data section
lifetime-->thru out the program
scope-->thru out the program

#include <iostream>
using namespace std;
void fun();
int a=10;
int main()
{
    cout<<"Hello World";
    fun();
}
void fun()
{

    cout<<a;
}
====================================================
Datatypes in c++

All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data they can store. 
Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type requires a different amount of memory. 

C++ supports the following data types:

Primary or Built-in or Fundamental data type:
These data types are built-in or predefined data types and can be used directly by the user to declare variables. example: int, char, float, bool, etc. 
Integer: The keyword used for integer data types is int. Integers typically require 4 bytes of memory space and range from -2147483648 to 2147483647.  
Character: Character data type is used for storing characters. The keyword used for the character data type is char. Characters typically require 1 byte of memory space and range from 0 to 255.  
Boolean: Boolean data type is used for storing Boolean or logical values. A Boolean variable can store either true or false. The keyword used for the Boolean data type is bool. 
Floating Point: Floating Point data type is used for storing single-precision floating-point values or decimal values. The keyword used for the floating-point data type is float. Float variables typically require 4 bytes of memory space. 
Double Floating Point: Double Floating Point data type is used for storing double-precision floating-point values or decimal values. The keyword used for the double floating-point data type is double. Double variables typically require 8 bytes of memory space. 
============================================================================
// C Program to implement Boolean data type
#include <stdbool.h>
int main()
{
      // Boolean data types declared
    bool a = true;
    bool b = false;
    printf("True : %d\n", a);
    printf("False : %d", b);
}
===========================================================================================
C++ I/O operation is using the stream concept. Stream is the sequence of bytes or flow of data. It makes the performance fast.
If bytes flow from main memory to device like printer, display screen, or a network connection, etc, this is called as output operation.
If bytes flow from device like printer, display screen, or a network connection, etc to main memory, this is called as input operation.

Header files available in C++ for Input/Output operations are: 
iostream: iostream stands for standard input-output stream. This header file contains definitions of objects like cin, cout, cerr, etc.


Different streams are used to represent different kinds of data flow.
==>istream is the class representing i/p stream,ostream is the class representing the o/p stream..to achiever the console input/output operations ,objects of these stream classes are used.
==>to manage input output operations predefined obj cin,cout..

Standard output stream (cout): Usually the standard output device is the display screen. The C++ cout statement is the instance of the ostream class. It is used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).
==>ostream class availabe in iostream.h thats why we have to include this headerfile


standard input stream (cin): Usually the input device in a computer is the keyboard. C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. 
The extraction operator(>>) is used along with the object cin for reading inputs. The extraction operator extracts the data from the object cin which is entered using the keyboard.

#include <iostream>
using namespace std;
 
int main()
{
    int age;
 
    cout << "Enter your age:";
    cin >> age;
    cout << "\nYour age is: " << age;
 
    return 0;
}

Un-buffered standard error stream (cerr): The C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.

// C++ program to illustrate std::cerr 
  
#include <iostream> 
using namespace std; 
int main() 
{ 
  
    // This will print "Welcome to GfG" 
    // in the error window 
    cerr << "Welcome to GfG! :: cerr"; 
  
    // This will print "Welcome to GfG" 
    // in the output window 
    cout << "Welcome to GfG! :: cout"; 
    return 0; 
} 
In the above program the Output of Line 11 will display an error window as:
RunTime Error in CPP code:

Welcome to GfG! :: cerr
==========================================================================
\n-->back\ character   endl-->manipulator
takes 1 byte                   no byte
==============================================================================
Constants:

  const keywords is used to define the constant value that cannot change during program execution. It means once we declare a variable as the constant in a program, the variable's value will be fixed and never be changed. If we try to change the value of the const type variable, it shows an error message in the program.

Use const keywords with different parameters:

Use const variable
Use const with pointers
Use const pointer with variables
Use const with function arguments
Use const with class member functions
Use const with class data members
Use const with class objects

1. Const variable
It is a const variable used to define the variable values that never be changed during the execution of a program. And if we try to modify the value, it throws an error.

Syntax

const data_type variable_name;   
Example: Program to use the const keyword in C++

Let's create a program to demonstrate the use of the const keyword in the C++ programming language.

#include <iostream>  
#include <conio.h>  
using namespace std;  
int main ()  
{  
// declare the value of the const  
const int num = 25;  
num = num + 10;  
return 0;  
}  

Note: While the declaration of the const variable in the C++ programming, we need to assign the value of the defined variables at the same time; else, it shows the compile-time error.
Note:Constants cannot appear on LHS of assignment operator(=)

use of const:
In C, a variable cannot be used to declare the size of an array. The size has to be defined using #define. Whereas,in c++,the size of an array can be specified using a const variable.
ex:
const int SIZE=10;
char arr[SIZE];//valid in c++ but invalid in c


=========================================================================
The const keyword can be used in pointer declarations,to make the pointer or the data to which the pointer is pointing to 
or both as constant.

1) Constant pointer to an integer
To create a const pointer, we need to use the const keyword before the pointer's name. We cannot change the address of the const pointer after its initialization, which means the pointer will always point to the same address once the pointer is initialized as the const pointer.

Example: Program to demonstrate the constant pointer using the const keyword

#include <iostream>  
using namespace std;  
int main ()  
{  
// declaration of the integer variables  
int x = 10, y = 20;  
// use const keyword to make constant pointer  
int* const ptr = &x; //  const integer ptr variable point address to the variable x  
  
// ptr = &y; // now ptr cannot changed their address  
*ptr = 15; // ptr can only change the value  
cout << " The value of x: " << x << endl;  
cout << " The value of ptr: " << *ptr << endl;  
return 0;  
}   
Output

The value of x: 15
The value of ptr: 15
In the above program, pointer ptr pointing to the address of int variable 'x' and ptr variable cannot be changed their address once it initialized, but the pointer ptr can change the value of x.

2. Pointer to a constant integer
It means the pointer points to the value of a const variable that cannot change.

Declaration of the pointer to the constant variable:
const int* x;   
Here, x is a pointer that point to a const integer type variable, and we can declare a pointer to the constant variable as,

char const* y;  
In this case, y is a pointer to point a char type const variable.

Example: Program to use the const keyword with a pointer to constant variable

#include <iostream>  
using namespace std;  
int main ()  
{  
// declare integer variable  
int x = 7, y = 10;  
  const int *ptr = &x; // here x become constant variable  
cout << " \n The initial value of ptr:" << *ptr;  
cout << " \n The value of x: " <<x;  
  
// *ptr = 15; It is invalid; we cannot directly assign a value to the ptr variable  
ptr = &y; //  here ptr variable pointing to the non const address 'y'  
  
cout << " \n The value of y: " <<y;  
cout << " \n The value of ptr:" << *ptr;   
return 0;  
}  

The initial value of ptr: 7
The value of x: 7
The value of y: 10
The value of ptr: 10
In the above program, pointer ptr points to the const int (x) variable, and the value of the int (x) variable can never change.

3)Constant pointer to a Constant Integer

int num1=10,num2=20;
const int *const ptr=&num1;
//ptr is a constant pointer to a constant integer

In this case,neither the address in the pointer be changed nor the contents at that address can be modified using that
pointer.

ptr=&num2;//not allowed
(*ptr)++;//not allowed
*ptr=20;//not allowed
=============================================================================================
Array in C++

In C++, an array is a data structure that is used to store multiple values of similar data types in a contiguous memory location.

Array Declaration in C++
In C++, we can declare an array by simply specifying the data type first and then the name of an array with its size.
data_type array_name[Size_of_array];
Example

int arr[5];
Here,

int: It is the type of data to be stored in the array. We can also use other data types such as char, float, and double.
arr: It is the name of the array.
5: It is the size of the array which means only 5 elements can be stored in the array.

Take Inputs from User and Store Them in an Array
#include <iostream>
using namespace std;

int main() {

  int numbers[5];

  cout << "Enter 5 numbers: " << endl;

  //  store input from user to array
  for (int i = 0; i < 5; ++i) {
    cin >> numbers[i];
  }

  cout << "The numbers are: ";

  //  print array elements
  for (int n = 0; n < 5; ++n) {
    cout << numbers[n] << "  ";
  }

  return 0;
}



The C++ Program to Illustrate How to Find the Size of an Array
C++
#include <iostream> 
using namespace std; 
  int main() 
{ 
    int arr[] = { 1, 2, 3, 4, 5 }; 
  
    // Size of one element of an array 
    cout << "Size of arr[0]: " << sizeof(arr[0]) << endl; 
  
    // Size of array 'arr' 
    cout << "Size of arr: " << sizeof(arr) << endl; 
  
    // Length of an array 
    int n = sizeof(arr) / sizeof(arr[0]); 
  
    cout << "Length of an array: " << n << endl; 
  
    return 0; 
}
 
// C++ Program to Illustrate that Array Name is a Pointer 
// that Points to First Element of the Array 
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    // Defining an array 
    int arr[] = { 1, 2, 3, 4 }; 
  
    // Define a pointer 
    int* ptr = arr; 
  
    // Printing address of the arrary using array name 
    cout << "Memory address of arr: " << &arr << endl; 
  
    // Printing address of the array using ptr 
    cout << "Memory address of arr: " << ptr << endl; 
  
    return 0; 
}

// C++ Program to Print Array Elements without Indexing 
#include <iostream> 
using namespace std; 
  
int main() 
{ 
  
    // Define an array 
    int arr[] = { 11, 22, 33, 44 }; 
  
    // Print elements of an array 
    cout << "first element: " << *arr << endl; 
    cout << "Second element: " << *(arr + 1) << endl; 
    cout << "Third element: " << *(arr + 2) << endl; 
    cout << "fourth element: " << *(arr + 3) << endl; 
  
    return 0; 
}


===================================================================
Two Dimensional Array in C++
In C++, a two-dimensional array is a grouping of elements arranged in rows and columns. Each element is accessed using two indices: one for the row and one for the column, which makes it easy to visualize as a table or grid.

Syntax of 2D array

data_Type array_name[n][m];
Where,

n: Number of rows.
m: Number of columns.



// c++ program to illustrate the two dimensional array 
#include <iostream> 
using namespace std; 
  
int main() 
{ 
    // Declaring 2D array 
    int arr[4][4]; 
  
    // Initialize 2D array using loop 
    for (int i = 0; i < 4; i++) { 
        for (int j = 0; j < 4; j++) { 
            arr[i][j] = i + j; 
        } 
    } 
  
    // Printing the element of 2D array 
    for (int i = 0; i < 4; i++) { 
        for (int j = 0; j < 4; j++) { 
            cout << arr[i][j] << " "; 
        } 
        cout << endl; 
    } 
  
    return 0; 
}

Output
0 1 2 3 
1 2 3 4 
2 3 4 5 
3 4 5 6 

=======================================================================


derived a new class from existing class/classes...all A class property is passed to B class..

allows reusability + extensibility(adding new features)....

polymorphiosm
poly-->many
morp-->form/kind
we are able to use 1 obj in many forms....it allows user to use object for different purpose

===========================================================================================================================
oop feature
data hiding
our internal data shld not go outside. by declaring data private,we can make outside person unable
to access my data 
class Account
{
private double bal;
public double getbal()
{
//validation
if(valid)
return bal;
}
}
adv of data hiding
security
===================================================================
Abstraction(not complete)
hiding internal implementation just highlight set of service for what we are offering.  By using gui screen we can offer abstaction.
atm card.. 
using abstraction 2 different application also can communicate with each other w/o highlighting internal implementation.

adv
1)security-->outside person doesnot know how my service is implemented
2)w/o affecting enduser we can able to perform any changes in internal design. changing 1 tech to another internally
===============================================================
Encapsulation
process of grouping datamembers and corresponding methosd into a single unit..
if any component follows data hiding and abstraction that component is said to be encapsulated component.
ex: class account
{
private double bal;//data hiding
public double getbal()//balenqiry
{
//validate
return bal;

}
//setter method  //deposit


provide gui screen for abstraction
===============================================================================
inheritance--------->is a relationship

polymorphism-->one person is behaving different ways

============================================================
Encapsulation is a mechanism used to hide data,internal structure and inmplementation details of an object .The hidden data can be accessed only thru public interfaces provided to the user.
ex:the internal components of a telvision and there working are hidden from end user.
-==========================
An object is an entity which has well defined structure and behaviour.
state of an object includes the current values of all its attributes.

polymorphism:
the ability of different types of related objects to respond to same message in there own ways
here the same command move is used to  move remote controlled objects like car and plane.
both the toys move but the way in which all these objects respomd to the command will be different.
extensibilty-->window


===========================================================================
Reference variable..

==>Reference is a new datatype(derived datatype) introduced in c++ and this kind of variable is called as reference variables.In c derived dataypes are pointer,array but in c++ along with this , we can use reference datype as derived
datatype.
==>In c++ we have pass by reference. but why?
==>In call by address,we have to declared formal parameter as a pointer and pointer holds address.
 problem is we can initialise any  variable address in future.First  variable address is passed,later we can change address inside pointer. Means we can initialize another variable address into this pointer, due to this which variable adress it is going to store,makes confusion. Thats why pointer is not secured.
==>To overcome the above limitations, reference datatype is introduced.

1)A reference variable is an alias, that is, another name for an already existing variable.
2)A variable can be declared as a reference by putting '&' in the declaration. 

syntax:
data_type &refname = variable;

ex:
int num=10;
int &refnum=num;

==>num is an integer variable, located at some address which is initialized to a value 10.
==>refnum is a another name for variable num, therefore refnum is a reference to num.

3)We can access the contents of the variable through either the original variable name or the reference  name. 
ex:
int i = 17;
int &r = i;
r is the reference name for the original variable name i.

#include <iostream>
using namespace std;
 int main ()
{
   int    i;
   double d;
   int &r = i;
   double &s = d;
     i = 5;
   cout << "Value of i : " << i << endl;
   cout << "Value of i reference : " << r  << endl;
    d = 11.7;
   cout << "Value of d : " << d << endl;
   cout << "Value of d reference : " << s  << endl;
}


4)No seperate memory is allocated for a reference.Its just an alternative name given to the reference variable.
5)You cannot have NULL reference. Reference should always be initialized with some variable.
    reference must be initialized at the time of the declaration.

#include <iostream>  
using namespace std;  
int main()  
{  
int a=10; // variable initialization  
int &b=a; // b reference to a  
std::cout << "value of a is " <<b<< std::endl;  
return 0;  
} 

Output:
 value of a is 10  
we have created a reference variable, i.e., 'b'. At the time of declaration, 'a' variable is assigned to 'b'. If we do not assign at the time of declaration, then the code would look like:

int &b;  
&b=a;    
The above code will throw a compile-time error as 'a' is not assigned at the time of declaration.

6)Once a reference is initialized to an object, it cannot be  refer to another object i.e it is secured. 
#include <iostream>  
using namespace std;  
int main()  
{  
int x=11; // variable initialization  
int z=67;  
int &y=x; // y reference to x  
int &y=z; // y reference to z, but throws a compile-time error.  
return 0;
}  
==>reference is a rigid connection.

7)Reference can pass as a parameter to function.

==>References can also be passed as a function parameter. It does not create a copy of the argument and behaves as an alias for a parameter. It enhances the performance as it does not create a copy of the argument.
Pass by reference will reduce the complexity  generated by pointers in pass by address.

#include<iostream>
using namespace std;
void swap(int&, int&);
int main()
{
	int a=10,b=20;
	cout<<"enter values of a & b\n"<<endl;
	cin>>a>>b;
	swap(a,b);
	cout<<"after swapping "<<endl;
	cout<<"values of a & b is"<<a<b<<endl;
	return 0;
}
void swap(int& p, int& q)
{
	int temp;
	temp=p;
	 p=q;
	q=temp;
}
==>In c++,reference is also used to share data between functions i.e pass by reference.

ex:
void main()
{
int a=100;
int &b=a;
int &c=b;
cout<<a<<b<<c;
c=200;
cout<<a<<b<<c;
}
=====================================================================================================
Difference between pointer and reference;
1)pointer is a flexible connection. it can point to any variable at a given point of a program.
Reference is a rigid connection,reference once created,cannot refer to any other object.

2)pointer has to be dereferenced using * operator to access the value at the address pointed by it.
A reference has direct connection as it is another name for the same memory location.

3)Reference cannot be null whereas pointer can point to null to indicate that they are not pointing to any valid thing. .

4)Array of pointers can be created,array of references cannot be created.
=====================================================================================================
Return by Reference

Reference can also be returned from a function.

1) Reference function cannot return constant
#include<iostream>
using nmespace std;
int & num()
{
	return 10;
}
int main()
{
	num();
}

2)Local variable should never be returned by reference, It is because when the function goes out of scope,all its
locaL variables are popped out from the stack. if reference would be returned for a variable that no longer exists,this may caused unpredictable behaviour in the program.

3)In c++,if a function retuns a reference variable,function call can appear on LHS of assignment operator.
Local variable can returned by reference.
int a;
int & num()
{
	return a;
}
int main()
{
	num()=10;
	cout<<num;
}

-----------------------------------------------------------------------------------------------------
Excercise 1:
#include <iostream>
using namespace std;
 
int& fun()
{
    static int x = 10;
    return x;
}
int main()
{
    fun() = 30;
    cout << fun();
    return 0;
}

Excercise 2:
#include <iostream>
using namespace std;
 
int fun(int& x) 
{
 return x;
 }
int main()
{
    cout << fun(10);
    return 0;
}

Excercise 3:
#include <iostream>
using namespace std;
 int main()
{
    int* ptr = NULL;
    int& ref = *ptr;
    cout << ref << '\n';
}
--------------------------------------------------------------------------------
===================================================================================
STATIC  VARIABLE
==>sometimes only one copy of a variable is required between all the objects of the same class,rather than having each object maintaining its own copy.in such case,that data members is declared as static.only one copy of static variable is created on data section and that copy is shared between all the object of the same class.Therefore static variable is called as class variable.
==>static data members are not part of the object,they are stored seperately.
==>Variable declared with static keyword are called as static variable.
==> Static Variable stored on data section
==>changes to the static variable affects all the instance of the same class.
==>It is initialized before any object of this class is created, even before the main starts.
==>Static members are only declared in a class declaration, not defined. They must be explicitly defined outside the class using the scope resolution operator.

Static variables in a Function: When a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of the variable in the previous call gets carried through the next function call. This is useful for i application where the previous state of function needs to be stored. 
#include <iostream>
using namespace std;
 void demo()
{
    static int count = 0;
    cout << count << " ";
     count++;
}
 int main()
{
    for (int i = 0; i < 5; i++)
        demo();
    return 0;
}

==>static variable is used to count the number of object created.

STATIC FUNCTION
1)function declare with static keyword is called as static function
2)static function is invoked by class name
3)syntax:
 classname::function name();
Memory efficient: Now we don't need to create instance for accessing the static members, so it saves memory.
4)This pointer is not passed to the static function.therefore static mem fun cannot access non static data member.
5)static function access only static data but a non static function can access both static as well as non static

Accessing static data member
i)if the static data member is public in the class then it can be accessed outside the class using classname::staticmembers;
2)if it is a private variable then it can be accessed either through non static member function and static member function.

=============================================================================
The reason we need Static member function:
1)Static members are used to store information that is shared by all objects in a class. 
2)keep track of the quantity of newly generated objects of a specific class type using a static data member as a counter. 

==================================================================================
Ex:
It is used to refer the common property of all objects such as rateOfInterest in case of Account, companyName in case of Employee etc.


#include <iostream>  
using namespace std;  
#include<string.h>
class Account {  
   public:  
       int accno;     
       char name[10];  
       static float rateOfInterest;   
       Account(int accno, char* name)   
        {    
             this->accno = accno;    
           strcpy(this->name,name);   
        }    
       void display()    
        {    
            cout<<accno<<"   "<<name<<"   "<<rateOfInterest<<endl;   
        }    
};  
float Account::rateOfInterest=6.5;  
int main() {  
    Account a1 =Account(201, "Sanjay"); 
    Account a2=Account(202, "Nakul");  
    a1.display();    
    a2.display();    
    return 0;  
} 

===========================================================================================
C++ static field example: Counting Objects

#include <iostream>  
using namespace std;  
class complex
{
	int real,img;
public:	static int cnt;
	public:
		complex()
		{
			cout<<"default is invoked\n";
			real=5;
			img=5;
			cnt++;
		}
		complex(int real,int img)
		{
			cout<<"parametrized is invoked\n";
			this->real=real;
			this->img=img;
			cnt++;	
		}
		static int getcnt()
		{
			return cnt;
		}
};
//datatype classname::staticvar_name=value;
int complex::cnt=0;//memory alloaction takes place
int main()
{
	complex c1;
	complex c2(10,10);
	cout<<"no of obj created is   "<<complex::getcnt();
	cout<<"sizeoof obj is     "<<sizeof(c1)<<endl;
	cout<<complex::cnt;//possible only if data member is public
}
 ================================================
Excercise 1:
#include<iostream>
using namespace std;
class complex
{
	int real,img;
	public:static const int cnt;
	private:static const int cnt1;
	public:
		complex()
		{
			cout<<"default is invoked\n";
			real=5;
			img=5;
		//	cnt++;//not allowed
		}
		static int getcnt()
		{
			return cnt1;
		}
};
const int complex::cnt=5;//memory alloaction takes place
const int complex::cnt1=10;
int main()
{
	complex c1;
	cout<<"no of obj created is   "<<complex::getcnt();
	cout<<"sizeoof obj is     "<<sizeof(c1)<<endl;
	cout<<complex::cnt;
	//cout<<complex::cnt1;

}

Excercise 2:
#include <iostream>
using namespace std;

class Test
{
	static int x;
public:
	Test() { x++; }
	static int getX() {return x;}
};
int Test::x;
int main()
{
	cout << Test::getX() << " ";
}

===================================================================
Excercise 3:
#include <iostream>
using namespace std;
 
class Player
{
private:
    int id;
    static int next_id;
public:
    int getID() { return id; }
    Player()  {  id = next_id++; }
};
int Player::next_id = 1;
 
int main()
{
  Player p1;
  Player p2;
  Player p3;
  cout << p1.getID() << " ";
  cout << p2.getID() << " ";
  cout << p3.getID();
  return 0;
}

Excercise 4:
Which of the following is true?
a)Static methods cannot be overloaded.
b)Static data members can only be accessed by static methods.
c)Non-static data members can be accessed by static methods.
d)Static methods can only access static members (data and methods)

=============================================================================
Some interesting facts about static member functions in C++

1)Keyword virtual cannot be used with static member functions
2)static member functions cannot have the same name as a non static function that has same argument types 
within the class.
3)A static member function can not be declared with const.
#include<iostream>
class Test {      
   static void fun() const 
   { // compiler error
     return;
   }
};
  int main()
{
   
}

4)'this' keyword is unavailable for static member functions
#include <iostream>
using namespace std;

class Test
{
     int x;
public:
	Test() {
	    x=10; }
	static int getX() 
	{
	    return this->x;
	}
	 
};
int Test::x;
int main()
{
	cout << Test::getX() << " ";
}

==============================================================
Default Arguments
A default argument is a value provided in a function declaration that is automatically assigned by the compiler if the calling function doesn’t provide a value for the argument. 

Characteristics for defining the default arguments

Following are the rules of declaring default arguments -

The values passed in the default arguments are not constant. These values can be overwritten if the value is passed to the function. If not, the previously declared value retains.
During the calling of function, the values are copied from left to right.
All the values that will be given default value will be on the right.

#include <iostream>  
using namespace std;  
 void add(int=1,int=2,int=3,int=4);
int main() 
{
	add();
	add(10);
	add(10,20);
	add(10,20,30);  
    add(10,20,30,40);
    return 0;  
} 
void add(int a,int b,int c,int d)
{
	cout<<a+b+c+d<<endl;//10 19 37 100
 } 


#include <iostream>
using namespace std;
void display(char = '*', int = 3);
int main() {
    int count = 5;

    cout << "No argument passed: ";
    display(); 
    
    cout << "First argument passed: ";
    display('#'); 
    
    cout << "Both arguments passed: ";
    display('$', count); 

    return 0;
}
void display(char c, int count) {
    for(int i = 1; i <= count; ++i)
    {
        cout << c;
    }
    cout << endl;
}



#include<iostream>
using namespace std;
void func(int a, bool flag = true)
{
		if (flag == true ) 
		{
			cout<< "Flag is true. a = " << a;
      	        }
		else
		{
			cout<< "Flag is false. a = " << a;
        	}
}
int main()
{
	func(200, false);
}

Keypoints:Default arguments are different from constant arguments as constant arguments can’t be changed whereas default arguments can be overwritten if required.
==============================================
If we are defining the default arguments in the function definition instead of the function prototype, then the function must be defined before the function call.

#include <iostream>
using namespace std;

int sum(int x, int y, int z = 5, int w = 10) 
{
    return (x + y + z + w);
}
int main()
{
    cout << sum(10, 15) << endl;
    cout << sum(10, 15, 25) << endl;
    cout << sum(10, 15, 25, 30) << endl;
   
}

=======================================================
points to remember

1)Once we provide a default value for a parameter, all subsequent parameters must also have default values. For example,
// Invalid
void add(int a, int b = 3, int c, int d);

// Invalid
void add(int a, int b = 3, int c, int d = 4);

// Valid
void add(int a, int c, int b = 3, int d = 4);

2)Default values shld be given from trailing ends.i.e from right to left
void add(int a,int b=3,int c=3,int d=4);//valid compulsary we have to pass 1 argument from function call
void add(int a=4,int b=3,int c=3,int d);//invalid
void add(int a=1,int b,int c=3,int d=4);//invalid

===========================================================================================
Advantages of Default Arguments:

Default arguments are useful when we want to increase the capabilities of an existing function as we can do it just by adding another default argument to the function.
It helps in reducing the size of a program.
It provides a simple and effective programming approach.

=============================================================================================
Array of Integer pointers
#include <iostream>  
using namespace std;  
int main()  
{ 
    int ptr1[5]; // integer array declaration  
    int *ptr2[5]; // integer array of pointer declaration  
    cout << "Enter five numbers :" <<endl;  
    for(int i=0;i<5;i++)  
    {  
        cin >> ptr1[i];  
    }  
    for(int i=0;i<5;i++)  
    {  
        ptr2[i]=&ptr1[i];   
    }    
  cout << "The values are" << endl; 
    for(int i=0;i<5;i++)  
    {  
        cout << *ptr2[i] << endl;  
    }
	
    }  

Array of Pointer to Strings

==>An array of pointers to strings is a data structure that holds multiple pointers, each pointing to a string. It allows you to store and manipulate a collection of strings in memory.
==>An array of pointer to strings is an array of character pointers that holds the address of the first character of a string or we can say the base address of a string.

The following are the differences between an array of pointers to string and two-dimensional array of characters:
==>An array of pointers to string is more efficient than the two-dimensional array of characters in case of memory consumption because an array of pointer to strings consumes less memory than the two-dimensional array of characters to store the strings.
==>In an array of pointers, the manipulation of strings is comparatively easier than in the case of 2d array. We can also easily change the position of the strings by using the pointers.

#include <iostream>  
using namespace std;  
int main()  
{  
  char *names[5] = {"rohan","ram","rahul","rohit","rachana"};  
for(int i=0;i<=5;i++)  
    { 
		int j=0; 
        cout << names[i] << endl; 
	 cout << (names+i) << endl; 
	  cout << *(names+i) << endl;
		   for(; j<=5; j++)
		   cout << *(*(names+i)+j);
		   cout<<endl;
    }  
    cout<<sizeof(names); 
}  

==========================================================
#include <iostream>  
using namespace std;  
int main()  
{  
  char names[5][8] = {"rohan","geeta","rahul","rohit","rachana"};  
    for(int i=0;i<=5;i++)  
    { 
		 cout << names[i] << endl; 
		 cout<< *names[i]<<endl;
		 cout<<*(names+1)+0<<endl;
    }
    cout<<"---------------------------------------";
    for(int i=0;i<=5;i++)  
    { 
        for(int j=0;j<=5;j++)
        {
            cout<< names[i][j];
        }
        cout<<endl;
    }
    cout<<"======================================="<<endl;
    for(int i=0;i<=5;i++)  
    { 
        for(int j=0;j<=5;j++)
        {
            cout<<*(names+i)+j<<endl;
        }
        cout<<endl;
    }
    
    cout<<sizeof(names); 
}  
================================================================================
Constructor:

Sequence after creation of object
1)memory  allocated by the compiler 
2)constructor invocation by compiler
3)memory initialization by constructor

==>Constructor in C++ is a special method that is invoked automatically at the time of object creation. It is used to initialize the data members of newly created objects.
==>The constructor in C++ has the same name as the class or structure. It constructs the values i.e. provides data for the object which is why it is known as constructor.
==>Constructor do not return value, hence they do not have a return type not even void.
==>Constructor cannot be constant member function.
 
The prototype of the constructor looks like 
     <class-name> (list-of-parameters);

Constructor can be defined inside the class declaration or outside the class declaration
a.    Syntax for defining the constructor within the class

        <class-name>(list-of-parameters)
        {
                  //constructor definition
        }

b.    Syntax for defining the constructor outside the class

        <class-name>: :<class-name>(list-of-parameters)
        {
                //constructor definition
        }

 Types of Constructors
Default Constructors: 
==>The constructor which doesn’t take any argument. It has no parameters. It is also called as no argument constructor.
==>If constructor is not defined in the source code by the programmer, then the compiler defined the default constructor implicitly during compilation and initilizes data members of class to garbage values.
==>There can be only one no argument constructor per class.

#include<iostream>
using namespace std;
class student
{
    int rno;
    char name[50];
    double fee;
    public:
    student()
    {
        cout<<"Enter the RollNo:";
        cin>>rno;
        cout<<"Enter the Name:";
        cin>>name;
        cout<<"Enter the Fee:";   
        cin>>fee;
    }   
      void display()
    {
        cout<<endl<<rno<<"\t"<<name<<"\t"<<fee;
    }
};
 int main()
{
    student s;  //constructor gets called automatically when we create the object of the class
    s.display();
    return 0;
}
====================================================================================
2. Parameterized Constructors: 

==>A constructor with parameters is called as parametrized constructor.
 ==> It is used to provide different values to distinct objects.
==>If Parametrized constructor is not defined in the source code by the programmer, then the compiler cannot defined the default copy of Parametrized constructor implicitly during compilation.
==>Constructors can be overloaded with different signatures.
Note: when the parameterized constructor is defined and no default constructor is defined explicitly, the compiler will not implicitly call the default constructor and hence creating a simple object as
Complex c;
Will flash an error

class student
{
    int rno;
    char name[50];
    double fee;
 
      public:
    student(int,char[],double);
    void display();
     
};
 
student::student(int no,char n[],double f)
{
    rno=no;
    strcpy(name,n);
    fee=f;
}   
 
void student::display()
{
    cout<<endl<<rno<<"\t"<<name<<"\t"<<fee;
}
     
int main()
{
    student s(1001,"Ram",10000);
    s.display();
    return 0;
}

==>When allocating memory, the constructor makes implicit calls to the new operators.
----------------------------------------------------------------------------------------------------------------------------------------------------------
#include<iostream>
using namespace std;
class complex
{
	int real,img;
	static int count;	
public:
	complex()
	{
		real=img=0;
		count++;
	}
	complex(int r,int i)
	{
		real=r;
		img=i;
		count++;
	}
	void display()
	{
		cout<<"complex no is "<<real<<"+"<<img<<"i"<<endl;
	}
	int getcount()
	{
		return count;
		//return real;
	}
	static int getcount1()
	{
		return count;
		//return real;//error
	}
};
int complex::count;//memory allocation takes place for static
int main()
{
	complex c1;
	complex c2(1,2);
	cout<<"no of objects created "<<complex::getcount1();
}
---------------------------------------------------------------------------------------

Excercise 1:
#include <iostream>
using namespace std;
 class Point {
    Point() { cout << "Constructor called"; }
};
int main()
{
    Point t1;
    return 0;
}

Excercise 2:
#include<iostream>
using namespace std;
class Point {
public:
    Point() { cout << "Constructor called"; }
};
int main()
{
   Point t1, *t2;
   return 0;
}

Excercise 3:
#include<iostream> 

using namespace std; 
#include<stdlib.h> 
 class Test 
{ 
public: 
   Test() 
   { cout << "Constructor called"; } 
}; 
 int main() 
{ 
    Test *t = (Test *) malloc(sizeof(Test)); 
    return 0; 
} 
 Unlike new, malloc() doesn’t call constructor.

Excercise 4:

#include<iostream>
using namespace std;
class temp
{
	int z;
	static int y;
public:
	temp();
	void show();
	void display();
};
int x;
int temp::y;
void temp::show()
{
	y++;
}
temp::temp()
{
	int z=200;
	x=100;
	cout<<"value of z is "<<z<<endl;
}
void temp::display()
{
	cout<<"value of x is "<<x<<endl;
	cout<<"value of y is  "<<y<<endl;
}
int main()
{
	temp t;
	t.show();
	t.show();
	t.display();
	cout<<sizeof(t);
}

Excercise 5:

#include<iostream>
using namespace std;
class item
{
public:
	static int x;
	int number;
public:
	void getdata(int a)
	{
		number=a;
		number++;
		x++;
	}
	void getcount()
	{
		x=10;
		cout<<"value is "<<x<<endl;
	}
	void getcount_1()
	{
		x++;
		cout<<"value is  "<<number<<endl;
		cout<<"value is "<<x<<endl;
	}
};
int number=9;
int item::x;
int main()
{
	item a;
	a.getcount();
	a.getdata(100);
	a.getcount_1();
	cout<<number<<endl;
	cout<<a.number;
}
==========================================================
Function Overloading

==>In C++, We can have more than one constructor in a class with same name, as long as each has a different list of signatures.This concept is known as Constructor Overloading 
==>Two or more function having same function name but different signatures is called as function overloading.
==> In Function Overloading Function name should be the same and the arguments should be different. 
==>The criteria to overload a constructor is to differ the number of arguments or the type of arguments. We dont consider return type as a criteria to overload a constructor.

Why Function Overloading?
Suppose you have to perform addition of the given numbers but there can be any number of arguments, if you write the function such as a(int,int) for two parameters, and b(int,int,int) for three parameters then it may be difficult for you to understand the behavior of the function because its name differs.
 
The parameters should follow any one or more than one of the following conditions for Function overloading:

1)Parameters should have a different type
add(int a, int b)
add(double a, double b)

#include <iostream>
using namespace std;
 void add(int a, int b)
{
  cout << "sum = " << (a + b);
}
 void add(double a, double b)
{
    cout << endl << "sum = " << (a + b);
}
 int main()
{
    add(10, 2);
    add(5.3, 6.2);
 }

2)Parameters should have a different number 
add(int a, int b)
add(int a, int b, int c)

#include <iostream>
using namespace std;
 void add(int a, int b)
{
  cout << "sum = " << (a + b);
}
 void add(int a, int b, int c)
{
    cout << endl << "sum = " << (a + b + c);
}
int main()
{
    add(10, 2);
    add(5, 6, 4);
  }

3)Parameters should have a different sequence of parameters.
add(int a, double b)
add(double a, int b)

#include<iostream>
using namespace std;
 void add(int a, double b)
{
    cout<<"sum = "<<(a+b);
} 
 void  add(double a, int b)
{
    cout<<endl<<"sum = "<<(a+b);
} 
 int main()
{
    add(10,2.5);
    add(5.5,6);
 }

------------------------------------
How does Function Overloading work?
Exact match:- (Function name and Parameter)
If a not exact match is found:–
               ->Char are promoted to an int.

               ->Float is promoted to double

If no match is found:
               ->C++ tries to find a match through the standard conversion.

ELSE ERROR
=============================================================================================
This Keyword

Each object gets its own copy of data members and all objects share a single copy of member functions.
Then now question is that if only one copy of each member function exists and is used by multiple objects, how are the proper data members are accessed and updated?
The compiler supplies an implicit pointer along with the names of the functions as 'this'.

==>whenever an object invokes member function,the address of that object is passed implicitly to the function as a hidden parameter . this pointer holds the address of the current object that invokes the fuction.
==>It is a constant pointer. The type of this pointer for the object cdate d1 will  be
cdate * const this; //it is a constant pointer to cdate object.
==>This pointer is used to retrieve objects address. In c to find out variable address,we use & symbol.in c++,to know current object address, this pointer is used.
==>this pointer is use to distinguish our data members from local variables when both are declared with the same name.To identify datamembers this pointer is used.
==>every non static members of c++ is having one hidden parameter called as this. static members never contains this.


Let's see the example of this keyword in C++ that refers to the fields of current class.
#include<iostream>
using namespace std;
class test
{
int a,b;
public:
void show()
{
a=10;
b=20;
cout<<"obj add"<<this<<endl;//print current class obj adddress
cout<<"a" <<this->a<<endl;
cout<<"b"<<this->b<<endl;
}
};
int main()
{
test t;
cout<<&t<<endl;
t.show();
}
========================

#include<iostream>
using namespace std;
class test
{
int a,b;
public:
void show(int a,int b)
{
	this->a=a;
	(*this).b=b;
//a=a;//this->a //(*this).a=a;(pointer to member)
//b=b;//this->b//(*this).b=b;

}
void display()
{
cout<<a<<b;
}
};
int main()
{
test t;
t.show(10,20);
t.display();
}

-----------------------------------------------------------------------------------------------------------------------
#include<iostream>
using namespace std;
class date
{
	int dd,mm,yy;
	public:
	void show();
	date(int,int,int);
	date();
};
date::date()
{
	this->dd=this->mm=this->yy=0;
}
 date::date(int dd,int mm,int yy)
{
	this->dd=dd;
	this->mm=mm;
	this->yy=yy;
}
 void date::show()
 {
	 cout<<"date is "<<this->dd<<"/"<<this->mm<<"/"<<yy<<endl;
 }
 int main()
{
	date d1(1,1,1);
	d1.show();
	date d2(2,2,2);
	d2.show();
}

======================================================================================
Passing and Returning Objects in C++
In C++ we can pass class’s objects as arguments and also return them from a function the same way we pass and return other variables.

Passing an Object as argument
To pass an object as an argument we write the object name as the argument while calling the function the same way we do it for other variables.
Syntax:  
function_name(object_name);

Returning Object as argument
Syntax: 
object = return object_name;



#include<iostream>
using namespace std;
class temp
{
	 int a;
public:
	void get();
	temp add(temp & b1) //This function will take object as arguments and  return object
	{
		temp aobj3;
		aobj3.a= this->a +   b1.a;
		return aobj3;
	}
	void show()
	{
		cout<<"value is   "<<a;
	}
};
void temp:: get()
	{
		cin>>this->a;
	}
int main()
{
	temp aobj1,aobj2;
	aobj1.get();
	aobj2.get();
	temp aobj4=aobj1.add(aobj2);
	aobj4.show();
}

Exercise 1:
Which of the following is true about this pointer?
(A) It is passed as a hidden argument to all function calls
(B) It is passed as a hidden argument to all non-static function calls
(C) It is passed as a hidden argument to all static functions
(D) None of the above

Answer: (B)

===========================================================================================
Array of Objects

==>In C++, an array of objects is a collection of objects of the same class type that are stored in contiguous memory locations. Since each item in the array is an instance of the class, each one's member variables can have unique value. This makes it possible to manage and handles numerous objects by storing them in a single data structure and giving them similar properties and behaviours.

syntax:
classname objectname[arraysize];

==>classname is the name of the class that the objects belong to
==>arrayname is the name of the array of objects
==>arraysize is the number of objects in the array .

Example:
Storing more than one Employee data. Let’s assume there is an array of objects for storing 30 employee's data.

#include<iostream>
using namespace std;
class Employee
{
  int id;
  char name[30];
  public:
    void getdata();
    void putdata();
};
void Employee::getdata()
{
  cout << "Enter Id : ";
  cin >> id;
  cout << "Enter Name : ";
  cin >> name;
}
void Employee::putdata()
{
  cout << id << " ";
  cout << name << " ";
  cout << endl;
}
int main()
{
  // This is an array of objects having maximum limit of 30 Employees
  Employee emp[30];
  int n, i;
  cout << "Enter Number of Employees - ";
  cin >> n;
   
  // Accessing the function
  for(i = 0; i < n; i++)
    emp[i].getdata();
   
  cout << "Employee Data - " << endl;
   
  // Accessing the function
  for(i = 0; i < n; i++)
    emp[i].putdata();
}

Advantages of Array of Objects: 

==>The array of objects represent storing multiple objects in a single name.
==>In an array of objects, the data can be accessed randomly by using the index number.
==>Reduce the time and memory by storing the data in a single variable.

#include<iostream>
using namespace std;
class item
{
  char name[30];
  int price;
  public:
  void getItem();
  void printItem();
};
 void item::getitem()
{
  cout << "Item Name = ";
  cin >> name;
  cout << "Price = ";
  cin >> price;   
}
 void item ::printitem()
{
  cout << "Name : " << name <<
          "\n";
  cout << "Price : " << price <<
          "\n";
}
 const int size = 3;
 int main()
{
  item t[size];
  for(int i = 0; i < size; i++)
  {
    cout << "Item  : " <<
            (i + 1) << "\n";
    t[i].getitem();
  }
  for(int i = 0; i < size; i++)
  {
    cout << "Item Details : " <<
             (i + 1) << "\n";
    t[i].printitem();
  }
}

===================================================================




















 main()
{
int *p;float *q,char *r;
p=new int(10);
r=new char('A');
}

void main()
{
int n;
cout<<"enter arraysize\n";
cin>>n;
int*p=new int[n];
for(int i=0;i<n;i++)
cin>>p[i]; //cin>>(p+i);
for(int i=0;i<n;i++)
cout<<p[i]; //cout<<*(p+i);
delete[] p;
}

================================================================

========================================================================================================
Constant Objects

==>To create constant object use const keyword.

==>When we create an object using the const keyword, the value of data members can never change till the life of the object in a program. The const objects are also known as the read-only objects.

==>constant objects invokes only constant member function. But a non constant object can invoke both i.e constant  as well as non constant function.

==>The data members of a constant object cannot accessed through any non const member function.

Syntax
const class_name obj_name;  
ex: const Complex c1(1,2);



Example: Let's create a program to use the constant objects in the C++ programming language.

#include <iostream>  
using namespace std;  
class ABC  
{  
public:  
int A;    
ABC ()  
{  
A = 10; 
}  
};  
int main ()  
{  
const ABC obj;  
cout << " The value of A: " << obj.A << endl;  
// obj.A = 20; // It returns a compile time error  
return 0;  
}  
Output

The value of A: 10
In the above program, we assign the value of A is 10, the compiler prints "The value of A: 10", and when we assign the value of A to 20, the object of the class returns the compile time error in the program.
=================================================================================================
 Constant Member function 

==>To make a member function constant,use const keyword. 
==>We can create a constant member function of a class by adding the const keyword after the name of the member function.
Syntax

return_type mem_fun() const  
{  
}   
In the above syntax, mem_fun() is a member function of a class, and the const keyword is used after the name of the member function to make it constant.

==>Those functions that do not alter the values of the data members, or the functions that are 'read only' can be 
made constant.

==>If a function is declared as const and the inplementation of that function tries to change the object by changing the value of any of its members,the compiler flags an error.

Example: Program to use the const keyword with the member function of class
class ABC  
{  
 
public:  
int A;  

void fun () const  
{  
 A = 0; // it shows compile time error  
}  
};  
  
int main ()  
{  
    ABC obj;  
    obj.fun();  
    return 0;  
}  
Output
The above code throws a compilation error because the fun() function is a const member function of class ABC, and we are trying to assign a value to its data member 'x' that returns an error.


// Constant member function defined outside the class
#include <iostream>
using namespace std;
 
class Demo {
    int x;
 
public:
    void set_data(int);
    int get_data() const;
};
 void Demo::set_data(int a) 
{
 x = a;
 }
int Demo::get_data() const 
{
 return x; 
}
main()
{
    Demo d;
    d.set_data(10);
    cout << d.get_data();
 
    return 0;
}

Output
10


// C++ program to demonstrate that const functions can be  called by non const objects
 
#include <iostream>
using namespace std;
 
class Test {
    int value;
 public:
    Test(int v = 0) { value = v; }
     int getValue() const { return value; }
};
 
int main()
{
    Test t(20);
    cout << t.getValue();
    return 0;
}
Output
20

// C++ program that demonstrate that non-const functions can not be called by const objects
 #include <iostream>
using namespace std;
 class Test {
    int value;
 
public:
    Test(int v = 0) { value = v; }
 
    // non const member function
    int getValue() { return value; }
};
 int main()
{
    // const object
    const Test t;
    cout << t.getValue();
    return 0;
}
//ERROR

// Demonstration of constant object show that constant object can only call const member function
 
#include <iostream>
using namespace std;
class Demo {
    int value;
 
public:
    Demo(int v = 0) { value = v; }
    void showMessage()
    {
        cout << "Hello World  Inside showMessage() Function";
    }
     // const member function
    void display() const
    {
        cout << "Hello world ";
    }
};
int main()
{
    
    const Demo d1;
     d1.showMessage();
    d1.display();

}


===============================================================================

Constant function Arguments
We can declare the function arguments as the constant argument using the const keyword. And if the value of function arguments is declared const, it does not allow changing its value.

Syntax

return_type fun_name (const int x)  
{  
}   
The fun_name() function contains a const argument whose value can never be changed once it defines in the program.

Example: Let's consider an example to use the const keyword with function arguments in the C++ programming language.

#include <iostream>  
using namespace std;  
int Test (const int num)  
{  
// if we change the value of the const argument, it throws an error.  
// num = num + 10;  
cout << " The value of num: " << num << endl;  
return 0;  
}  
int main ()  
{  
// call function  
Test(5);  
}  
Output

The value of num: 5
In the above program, the num is a constant argument, and we cannot update the num value. If we update the value of the num variable, it returns the compile-time error.



FAQ on constant object:
Q1. Can const objects of a class call non-const member functions?
Answer:
No,an object declared as const cannot be modified and hence, can invoke only const member functions as these functions ensure not to modify the object.

Q2. Can non-const objects of a class call const member function?
Answer:
When a function is declared as const, it can be called on any type of object.


FAQs on Const Member Functions
Q1. Can const objects of a class call non-const member functions?
Answer:

No,an object declared as const cannot be modified and hence, can invoke only const member functions as these functions ensure not to modify the object.

Q2. Can non-const objects of a class call const member function?
Answer:
When a function is declared as const, it can be called on any type of object.

Note: A constant member function can be overloaded with a function of same name.
ex:
void func() const;
void func();

class temp
{
public:
	void show();
	void show() const;
};
void temp::show()
{
	cout<<"in non constant show";
}
void temp::show()const
{
	cout<<"in  constant show";
}
int main()
{
	 temp t;
	t.show();
}

In this case, constness of the object will determoine which functions should  be invoked.

Note:Constructors and Destructors cannot be made constants.
===================================================================================

Memory Managment in c++:

What is Memory Management?
Memory management is a process of managing computer memory, assigning the memory space to the programs to improve the overall system performance.

Why is memory management required?
As we know that arrays store the homogeneous data, so most of the time, memory is allocated to the array at the declaration time. Sometimes the situation arises when the exact memory is not determined until runtime. To avoid such a situation, we declare an array with a maximum size, but some memory will be unused. To avoid the wastage of memory, we use the new operator to allocate the memory dynamically at the run time.

==>A typical memory representation of a C++ program consists of the following sections.This would help in understanding the part of the memory where ,which types of variables are stored.

==>Memory is divided into 2 segments
1)code segment:
The code segment where the compiled code of the program resides.It contains set of instructions in a program that
are executed step by step.

2)Data segment: Data segment is divided into three sections
a)stack section:where memory is allocated for local variables.
b)heap section:provides storage for variables that are dynamically allocated memory.
c)data section:provides  the storage for global and static variables.

Memory Management Operators
In C language, we use the malloc() or calloc() functions to allocate the memory dynamically at run time, and free() function is used to deallocate the dynamically allocated memory. C++ also supports these functions, but C++ also defines unary operators such as new and delete to perform the same tasks, i.e., allocating and freeing the memory.

==>Dynamic memory allocation in C/C++ refers to performing memory allocation manually by a programmer. Dynamically allocated memory is allocated on Heap
==>The most important use is the flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need it and whenever we don’t need it anymore

Difference between Static Memory Allocation and				 Dynamic Memory Allocation

1	Static Memory Allocation is done before program execution.	Dynamic Memory Allocation is done during program execution.
2	It uses stack for managing the static allocation of memory		It uses heap for managing the dynamic allocation of memory
3	In Static Memory Allocation, there is no memory re-usability	In Dynamic Memory Allocation, there is memory re-																usability and memory can be freed when not required

4	In static memory allocation, once the memory is allocated, the memory size can not change.	In dynamic memory 								allocation, when memory is allocated the memory size can be changed.

5	In this memory allocation scheme, execution is faster than dynamic memory allocation.	In this memory allocation 										scheme, execution is slower than static memory allocation.
6	In this memory is allocated at compile time.	In this memory is allocated at run time.
7	In this allocated memory remains from start to end of the program.	In this allocated memory can be released at any time during the program.

new and delete operators:

==>You can allocate memory at run time within the heap for the variable of a given type using a special operator in C++ which returns the address of the space allocated. This operator is called new operator.
If you are not in need of dynamically allocated memory anymore, you can use delete operator, which de-allocates memory previously allocated by new operator.

==>In c++,memory is allocated dynamically through the use of new operator and memory is freed using delete operator.

// declare an int pointer
int* pointVar;
// dynamically allocate memory using the new keyword 
pointVar = new int;
// assign value to allocated memory
*pointVar = 45;

Here, we have dynamically allocated memory for an int variable using the new operator.
 we have used the pointer pointVar to allocate the memory dynamically on heap section. This is because the new operator returns the address of the memory location.


delete Operator
Once we no longer need to use a variable that we have declared dynamically, we can deallocate the memory occupied by the variable.
For this, the delete operator is used. It returns the memory to the operating system. This is known as memory deallocation.
 This operator is mainly used either for those pointers which are allocated using a new operator;


The syntax for this operator is
delete pointerVariable;

For example, if we allocate the memory to the pointer using the new operator, and now we want to delete it. To delete the pointer, we use the following statement:

delete p;  

To delete the array, we use the statement as given below:
delete [] p;  

Some important points related to delete operator are:

1)It is either used to delete the array or non-array objects which are allocated by using the new keyword.
2)To delete the array or non-array object, we use delete[] and delete operator, respectively.
3)The new keyword allocated the memory in a heap; therefore, we can say that the delete operator always de-allocates the memory from the heap
4)It does not destroy the pointer, but the value or the memory block, which is pointed by the pointer is destroyed.


Example 1: C++ Dynamic Memory Allocation
#include <iostream>
using namespace std;
int main() {
  // declare an int pointer
  int* pointInt;
  // declare a float pointer
  float* pointFloat;
  // dynamically allocate memory
  pointInt = new int;
  pointFloat = new float;
  // assigning value to the memory
  *pointInt = 45;
  *pointFloat = 45.45f;
  cout << *pointInt << endl;
  cout << *pointFloat << endl;
int *p = new int(45);  
cout<<*p;
  // deallocate the memory
  delete pointInt;
  delete pointFloat;
delete p;
}

Output

45
45.45

Dynamic Memory Allocation for Arrays:

Consider you want to allocate memory for an array of characters, i.e. string of 100 characters. 
char * str=new char[100];
==>The above statement allocates memory for 100 characters on the heap and stores the address of the first memory location in the character pointer str. To allocate memory for more than one character, subscript is used to indicate the size.
==>memory is allocated for more than one character.In order to free all the space that has been allocated,subscript notation is used in delete statement.
delete[] str;

int main()
{
	char * str;
	str=new char[100];
	cin>>str;
	cout<<str;
	delete[] str;
}
 
Note: if [] is used with new, it should also be used with delete, otherwise it leads to memory leakage problem i.e only first element whose address is contained in the pointer is de-allocated resulting in the problem of memory leakage.

// C++ Program to store GPA of n number of students and display it
// where n is the number of students entered by the user

#include <iostream>
using namespace std;

int main() {

  int num;
  cout << "Enter total number of students: ";
  cin >> num;
  float* ptr;
    
  // memory allocation of num number of floats
  ptr = new float[num];

  cout << "Enter GPA of students." << endl;
  for (int i = 0; i < num; ++i) {
    cout << "Student" << i + 1 << ": ";
    cin >> *(ptr + i);
  }

  cout << "\nDisplaying GPA of students." << endl;
  for (int i = 0; i < num; ++i) {
    cout << "Student" << i + 1 << ": " << *(ptr + i) << endl;
  }

  // ptr memory is released
  delete[] ptr;

  return 0;
}
============================================================


Note:new operator internally invokes the function operator new() which in turn invokes the function malloc()
delete operator internally invokes the function operator delete() which in turn invokes the function free()
malloc and free() can be used in c++.but for the ease of use,new and delete operator are preferred.

The following are the advantages of the new operator over malloc() function:
1)It does not use the sizeof() operator as it automatically computes the size of the data object.
2)It automatically returns the correct data type pointer, so it does not need to use the typecasting.

Differences between the malloc() and new
1)The new operator constructs an object, i.e., it calls the constructor to initialize an object while malloc() function does not call the constructor. The new operator invokes the constructor, and the delete operator invokes the destructor to destroy the object. This is the biggest difference between the malloc() and new.
// C++ program to illustrate malloc()
// and new operator in C++
#include "bits/stdc++.h"
using namespace std;
 
// Class A
class A {
    int a;
 
public:
    int* ptr;
 
    // Constructor of class A
    A()
    {
        cout << "Constructor was Called!"
             << endl;
    }
};
 
// Driver Code
int main()
{
 
    // Create an object of class A
    // using new operator
    A* a = new A;
    cout << "Object of class A was "
         << "created using new operator!"
         << endl;
 
    // Create an object of class A
    // using malloc operator
    A* b = (A*)malloc(sizeof(A));
    cout << "Object of class A was "
         << "created using malloc()!"
         << endl;
 
    return 0;
}
Output
Constructor was Called!
Object of class A was created using new operator!
Object of class A was created using malloc()!
In the above program we can clearly see that while creating object using new operator Default Constructor was called and using malloc function Default Constructor was not called.

2)The new is an operator, while malloc() is a predefined function in the stdlib header file.

3)If the sufficient memory is not available in a heap, then the new operator will throw an exception while the malloc() function returns a NULL pointer.

4In the case of a new operator, we have to use the delete operator to deallocate the memory. But in the case of malloc() function, we have to use the free() function to deallocate the memory.

Differences between delete and free()

1)The delete is an operator that de-allocates the memory dynamically while the free() is a function that destroys the memory at the runtime.
2)When the delete operator destroys the allocated memory, then it calls the destructor of the class in C++, whereas the free() function does not call the destructor; it only frees the memory from the heap.
// C++ program to illustrate free()
// and delete keyword in C++
#include "bits/stdc++.h"
using namespace std;
 
// Class A
class A {
    int a;
 
public:
    int* ptr;
 
    // Constructor of class A
    A()
    {
        cout << "Constructor was Called!"
             << endl;
    }
 
    // Destructor of class A
    ~A()
    {
        cout << "Destructor was Called!"
             << endl;
    }
};
 
// Driver Code
int main()
{
 
    // Create an object of class A
    // using new operator
    A* a = new A;
    cout << "Object of class A was "
         << "created using new operator!"
         << endl;
 
    delete (a);
    cout << "Object of class A was "
         << "deleted using delete keyword!"
         << endl;
 
    cout << endl;
 
    A* b = (A*)malloc(sizeof(A));
    cout << "Object of class A was "
         << "created using malloc()!"
         << endl;
 
    free(b);
    cout << "Object of class A was "
         << "deleted using free()!"
         << endl;
 
    return 0;
}
Output
Constructor was Called!
Object of class A was created using new operator!
Destructor was Called!
Object of class A was deleted using delete keyword!

Object of class A was created using malloc()!
Object of class A was deleted using free()!
=================================================================

//accept no of subjects and name from the user dynamically and accept marks for each subject and display average and name
of the student

#include<iostream>
using namespace std;
int main()
{
	int n,m,i,sum=0;
	cout<<"accept no of subjects\n";
	cin>>n;
	cout<<"accept no of character\n";
	cin>>m;
	int * p_marks=new int [n];
	char * p_name=new char[m];
	cout<<"accept marks\n";
	for(i=0;i<n;i++)
	{
		cin>>p_marks[i];
	}
	for(i=0;i<n;i++)
	{
		sum=sum + p_marks[i];
	}
	cout<<"accept name\n";
	cin>>p_name;
	float avg=(float)sum/n;
	cout<<"average is  "<<avg;
	cout<<"name is  "<<p_name;
	delete [] p_name;
	delete[] p_marks;
}

=======================================================================================
Object created on heap

The new operator is used to create objects dynamically and the delete operator is used to delete objects dynamically. The dynamic objects can be created with the help of pointers.

Syntax:

ClassName *ptr_obj;              // pointer to object
ptr_obj = new ClassName    // Dynamic object creation
delete ptr_obj;                     // Delete object dynamically
				OR

Classname  * pointername=new classname(arguments);

/*#include<iostream>
using namespace std;
class student
{
	int rollno;
	char name[20];
	public:
	void display();
	student(int,char *);
};
student::student(int r,char * sptr)
{
	rollno=r;
	strcpy(name,sptr);
}
void student::display()
{
	cout<<"rollno is "<<rollno<<endl;
	cout<<"name = "<<name<<endl;
	cout<<"\n";
}
int main()
{
	student * ptr=new student(1,"rahul");
	ptr->display();
	
}
-----------------------------------------------------------------------------------------------

Need for deletion of the object:
To avoid memory leak as when an object is created dynamically using new, it occupies memory in the Heap Section.
If objects are not deleted explicitly then the program will crash during runtime.

Program 1: Create an object of the class which is created dynamically using the new operator and deleting it explicitly using the delete operator:
// C++ program to implement  dynamic objects 
#include<iostream> 
using namespace std; 
 class Test 
{ 
    int a, b; 
    public: 
           Test() 
        { 
            cout << "Constructor is called" <<  endl; 
            a = 1; 
            b = 2; 
        }; 
    
        // Destructor  
        ~Test() 
        { 
            cout << "Destructor is called" <<  
                     endl; 
        } 
    
        // Function to print values 
        // of data members 
        void show() 
        { 
            cout << "a = " <<  
                     a << endl; 
            cout << "b = " <<  
                     b << endl; 
        } 
}; 
int main() 
{ 
 
    Test *ptr;          
     ptr = new Test;   
    ptr->show();      
    delete ptr;      
    return 0; 
}
Output
Constructor is called
a = 1
b = 2
Destructor is called

Program 2: Create an array of objects using the new operator dynamically. Whenever an array of the object of a class is created at runtime then it is the programmer’s responsibility to delete it and avoid a memory leak:

// C++ program to create an array of 
// objects and deleting it explicitly 
#include <iostream> 
using namespace std; 
  
// Class 
class Student { 
  
public: 
    // Constructor 
    Student() 
    { 
        cout << "Constructor is called!\n"; 
    } 
  
    // Destructor 
    ~Student() 
    { 
        cout << "Destructor is called!\n"; 
    } 
  
    // Function to display message 
    void write() 
    { 
        cout << "Writing!\n"; 
    } 
}; 
  
// Driver Code 
int main() 
{ 
    // Create an array of the object 
    // dynamically 
    Student* student = new Student[3]; 
  
    // Function Call to write() 
    student[0].write(); 
    student[1].write(); 
    student[2].write(); 
  
    // De-allocate the memory 
    // explicitly 
    delete[] student; 
  
    return 0; 
}
Output:
Constructor is called!
Constructor is called!
Constructor is called!
Writing!
Writing!
Writing!
Destructor is called!
Destructor is called!
Destructor is called!

Program 3:

Below is the program where delete is used to delete an array of objects:

#include <iostream> 
using namespace std; 
class Student { 
  
public: 
    // Constructor 
    Student() 
    { 
        cout << "Constructor is called!\n"; 
    } 
  
    // Destructor 
    ~Student() 
    { 
        cout << "Destructor is called!\n"; 
    } 
  
    // Function to display message 
    void write() 
    { 
        cout << "Writing!\n"; 
    } 
}; 

int main() 
{ 
    
    Student* student = new Student[3]; 
  
    // Function call to write() 
    student[0].write(); 
    student[1].write(); 
    student[2].write(); 
  

    delete student; 
  
    return 0; 
}

Conclusion:
In C++, the single object of the class which is created at runtime using a new operator is deleted by using the delete operator, while the array of objects is deleted using the delete[] operator so that it cannot lead to a memory leak.
==========================================================

Math library functions

C++ being a superset of C, supports a large number of useful mathematical functions. These functions are available in standard C++ to support various mathematical calculations.

Instead of focusing on implementation, these functions can be directly used to simplify code and programs. In order to use these functions you need to include a header file- <math.h> or <cmath>.

sqrt()	This function takes a number as an argument and returns its square root value. The number can not be a negative value.
Consider a argument 'arg' :
square_root of a number=√arg  
Syntax
Syntax would be :

double sqrt(double arg);  
float sqrt(float arg);    
double sqrt(integral arg);  

// CPP Program to demonstrate errors in double sqrt()
#include <cmath>
#include <iostream>
using namespace std;
 
// Driver Code
int main()
{
    double answer;
    answer = sqrt(10);
    cout << "Square root of " << " is " << answer;
     return 0;
}

If we pass a negative value in the argument domain error occurs and the output will be the Square root of -a, which is -nan.

int abs(int)	This function takes an integer number as an argument and returns its absolute value. It means the output will always be positive regardless of the sign of the input.

// CPP program to illustrate
// abs() function
#include <math.h>
#include <iostream>
 
using namespace std;
 
int main()
{
    int val1, val2;
 
    /// finding absolute value using
    /// abs() function.
    val1 = abs(0.6);
    val2 = abs(-43);
 
    cout << "abs(22) = " << val1 << "\n";
    cout << "abs(-43) = " << val2 << "\n";
    return 0;
}

double pow(double, double)	This function takes one argument as base and another as exponent.
Consider a base 'b' and exponent 'e'.
Power=be
Syntax
Its syntax would be :

double pow(double b, double e);  
float pow(float b, float e);  

#include <iostream>  
#include<cmath>  
using namespace std;  
int main()  
{  
int base=4;  
  int exponent=2;  
  int power=pow(base,exponent);  
  std::cout << "Power of a given number is :" <<power;  
  return 0;  
}  
Output:

Power of a given number is :16
=============================================================
C++ Math ceil()
It rounds the value to the nearest integer which is not less than the given value.

For example :
ceil(8.1)=9.0;  
ceil(-8.8)=-8.0;  

Syntax
Suppose a number is 'x'. Syntax would be:
double ceil(double x);  
Parameter
x : It is the value that rounds to the nearest integer.
Return value
It returns the smallest integer value not less than x.

Example 1
Let's see a simple example by considering the positive value of x.

#include <iostream>  
#include<cmath>  
using namespace std;  
int main()  
{  
  float x=9.2;  
  std::cout << "Initial value of x is :"<<x;  
  cout<<'\n';  
  cout<<"final value of x is :"<<ceil(x);  
  return 0;  
}  
Output:

Initial value of x is :9.2
final value of x is :10   
Example 2
Let's see a simple example by considering the negative value of x.

#include <iostream>  
#include<cmath>  
using namespace std;  
int main()  
{  
  float x=-2.2;  
  std::cout << "Initial value of x is :"<<x;  
  cout<<'\n';  
  cout<<"final value of x is :"<<ceil(x);  
  return 0;  
}  
Output:

Initial value of x is :-2.2
final value of x is :-2   


C++ Math floor()
It rounds the value to the nearest integer which is not greater than the given value.

For example:

floor(8.2)=8.0;  
floor(-8.8)=-9.0;  
Syntax
Suppose a number is 'x'. Syntax would be :

double floor(double x);  
Parameter
x : It is the value that rounds to the nearest integer.

Return value
It returns the value that round to the nearest integer not greater than x.

AD
Example 1
Let's see a simple example by considering a positive value.

#include <iostream>  
#include<math.h>  
using namespace std;  
int main()  
{  
 float x=7.8;  
 std::cout << "Initial value of x is : " << x<<std::endl;  
cout<<"Now, the value of x is :"<<floor(x);  
 return 0;  
}  
Output:

Initial value of x is : 7.8
Now, the value of x is :7   
Example 2
Let's see a simple example by considering a negative value.

#include <iostream>  
#include<math.h>  
using namespace std;  
int main()  
{  
 float x=-10.2;  
 std::cout << "Initial value of x is : " << x<<std::endl;  
cout<<"Now, the value of x is :"<<floor(x);  
 return 0;  
}  
Output:

Initial value of x is : -10.2
Now, the value of x is :-11  

C++ Math round()
This function is used to round off the given value which can be either float or double.

For example:

round(5.8)= 6;  
round(-1.1)= -1;  
Syntax
Suppose a number is 'x'. Syntax would be:

return_type round(data_type x);  
Parameter
x : The value which can be either float or double.

Return value
It returns the rounded value of x. The return type of the value can be float, double or long double.

AD
Example 1
Let's see a simple example when the value of x is positive

#include <iostream>  
#include<math.h>  
using namespace std;  
int main()  
{  
    float x=8.3;  
    std::cout << "The value of x is : " <<x<< std::endl;  
    cout<<"Rounded value of x is : "<<round(x);  
    return 0;  
}  
Output:

The value of x is : 8.3
Rounded value of x is : 8   
Example 2
Let's see a simple example when the value of x is negative.

#include <iostream>  
#include<math.h>  
using namespace std;  
int main()  
{  
    double x=-9.9;  
    std::cout << "The value of x is : " <<x<< std::endl;  
    cout<<"Rounded value of x is : "<<round(x);  
    return 0;  
}  
Output:

The value of x is : -9.9
Rounded value of x is : -10


// C++ program to illustrate some of the
// above mentioned functions
 
#include <iostream>
#include <math.h>
using namespace std;
 
int main()
{
    double x = 2.3;
    cout << "Sine value of x=2.3 : " << sin(x) << endl;
    cout << "Cosine value of x=2.3 : " << cos(x) << endl;
    cout << "Tangent value of x=2.3 : " << tan(x) << endl;
 
    double y = 0.25;
    cout << "Square root value of y=0.25 : " << sqrt(y)
         << endl;
 
    int z = -10;
    cout << "Absolute value of z=-10 : " << abs(z) << endl;
    cout << "Power value: x^y = (2.3^0.25) : " << pow(x, y)
         << endl;
 
    
    x = 4.56;
    cout << "Floor value of x=4.56 is : " << floor(x)
         << endl;
 
 
 
    y = 12.3;
    cout << "Ceiling value of y=12.3 : " << ceil(y) << endl;
 
  
    y = 100.0;
    // Natural base with 'e'
    cout << "Log value of y=100.0 is : " << log(y) << endl;
 
    return 0;
}
=================================
Dynamic initialization of object in C++

==>Dynamic initialization of object refers to initializing the objects at a run time i.e., the initial value of an object is provided during run time.
==>It can be achieved by using constructors and by passing parameters to the constructors.
==>This comes in really handy when there are multiple constructors of the same class with different inputs.
==>Dynamic initialization of the object using a constructor is beneficial when the data is of different formats.

Dynamic Constructor:

The constructor used for allocating the memory at runtime is known as the dynamic constructor.
The memory is allocated at runtime using a new operator and similarly, memory is deallocated at runtime using the delete operator.

Ex:
// C++ program for dynamic allocation
#include <iostream>
using namespace std;
 class Demo {
    int* ptr;
 public:
      Demo()
    {
        // Dynamically initializing ptr using new
        ptr = new int;
        *ptr = 10;
    }
     // Function to display the value of ptr
    void display()
    {
        cout << *ptr << endl;
    }
};
 int main()
{
    Demo obj1;
     obj1.display();
}

Output
10
In the above example, new is used to dynamically initialize the variable in default constructor and memory is allocated on the heap.
The objects of the class Demo calls the function and it displays the value of dynamically allocated variable i.e ptr.



#include<iostream>
using namespace std;
class string1
{
	int len;
	char *ptr;
public:
	void chardisplay();
	string1();
	string1(char*);
	void stringdisplay();
	string1(char,int);
	string1(int);
};
string1::string1()
{
	len=1;
	ptr=new char[len];//new char[1],new char;
	*ptr='A';
}
void string1::chardisplay()
{
	cout<<"length is "<<len<<endl;
	cout<<"character is "<<*ptr<<endl;
}
void string1::stringdisplay()
{
	cout<<"length is "<<len<<endl;
	cout<<"string is "<<ptr<<endl;
}
string1::string1(char * sptr)
{
	len=strlen(sptr);
	ptr=new char[len+1];
	strcpy(ptr,sptr);
}
string1::string1(char ch,int l)
{
	int i;
	len=l;
	ptr=new char[len+1];
	for(i=0;i<len;i++)
	{
		ptr[i]=ch;
	}
	ptr[i]='\0';
}
string1::string1(int l)
{
	int i;
	len=l;
	ptr=new char[len+1];
	cout<<"accept string\n";
	cin>>ptr;
	strcpy(ptr,"rohit");

	/*cout<<"accept character by character\n";
	for(i=0;i<len;i++)
	{
		cin>>ptr[i];
	}
	ptr[i]='\0';*/
}
int main()
{
	string1 c1;
	c1.chardisplay();
	string1 c2("rahul");
	c2.stringdisplay();
	string1 c3('*',60);
	c3.stringdisplay();
	string1 c4(5);
	c4.stringdisplay();
}
#include<iostream>
using namespace std;
class temp
{
	int *ptr;
	int size;
public:
	temp();
	void get();
	void show();
	int max();
	int min();
};
temp::temp()
{
	cout<<"how many elements do u want to store\n";
	cin>>size;	
	ptr=new int[size];
}
void temp::get()
{
	cout<<"accept elements\n";
	for(int i=0;i<size;i++)
	cin>>ptr[i];
}
void temp::show()
{
	cout<<"value are\n";
	for(int i=0;i<size;i++)
	cout<<ptr[i]<<"\n";
}
int temp::max()
{
	int m=ptr[0];
	for(int i=1;i<size;i++)
	if(ptr[i]>m)
	m=ptr[i];
	return m;
}
int temp::min()
{
	int m=ptr[0];
	for(int i=1;i<size;i++)
	if(ptr[i]<m)
	m=ptr[i];
	return m;
}
int main()
{
	temp a;
	a.get();
	a.show();
	cout<<"maximum number is "<<a.max()<<endl;
	cout<<"minimum number is "<<a.min()<<endl;
}

===========================================================================
Copy Constructor

==>A copy constructor is a member function that initializes an object using another object of the same class. 
==>In simple terms, a constructor which creates an object by initializing it with an object of the same class, which has been created previously is known as a copy constructor.  
==>Copy constructor is used to initialize the members of a newly created object by copying the members of an already existing object.
==>Copy Constructor is a special type of member function with the same name as classname.
==>If a copy constructor is not defined in a class, the compiler defines one. This compiler defined copy constructor does a member wise copy of the elements i.e shallow copy. If the class doesnot have a pointer variable with dynamically allocated memory, then there is no need to explicitly defines a copy constructor in the class.

==>But if the class has a pointer variable to which memory is allocated dynamically, then the class must implement its own copy constructor. In this case, if user doesnot defined its own copy constructor,then the compiler's copy is invoked.This creates an object as a copy of another object.This shallow copy leads to the problem of dangling pointer.

What is Dangling Pointer and how this situation arises?
==>This problem particularly arises when there are two objects holding the address of a common memory location on the heap. If one of those object goes out of scope, the destructor is invoked, thus deleting the memory that it is pointing to. Now the other object, which is still in scope, but which was also pointing to the same memory location, contains the address of the memory , which has been freed by the destructor. The pointer holding an address to the memory that has been set free is referred to as the dangling pointer.

ex:
 cstring s1("hello");
cstring s2(s1); // to create s2 as a copy of s1
//The implicit copy constructor does a member wise copy of the elements.  pointer data member of s1 and s2 point to the same memory on heap. If either of the object goes out of scope, the destructor is invokes which will free the memory. This lead to runtime error when this free memory is accessed.

How Dangling pointer can be avoided?
==>To avoid dangling pointer,it is mandatory to have a copy constructor in a  class which contains  a pointer variable.
It allocates seperate memory location on the heap for the object being initialized. It also copies the contents of the object that is being copied to the newly allocated memory. This is know as deep copying.
==>Copy constructor takes a reference to an object of the same class as an argument.

class cstring
{
	int len;
	char* ptr;
	public:
cstring(const cstring &s)
{
	this->len=len;
	this->ptr=new char[len+1];
	strcpy(this->ptr,s.ptr);
}
};
int main()
{
 cstring s1("hello");
cstring s2(s1); 
}
//for the above statement
==>It is constant so that original object should not be modified .
==>It is passed by reference because if the object is passed by value, a copy is created on the stack. To create this local copy, again copy constructor will get call, It will be invoked again and again and so on. It will enter into a bad recursive loop.

Types of Copy Constructors

1. Default Copy Constructor:
==>Compiler provides a default copy constructor which does memberwise copying i.e shallow copying.
==>

// Implicit copy constructor Calling
#include <iostream>
using namespace std;
 
class Sample {
    int id;
 
public:
    void init(int x) { id = x; }
    void display() { cout << endl << "ID=" << id; }
};
int main()
{
    Sample obj1;
    obj1.init(10);
    obj1.display();
 
    // Implicit Copy Constructor Calling
    Sample obj2(obj1); // or obj2=obj1;
    obj2.display();
    return 0;
}



2.User defined copy constructor:
The copy constructor can be defined explicitly by the programmer. 
The process of initializing members of an object through a copy constructor is known as copy initialization.
It is also called member-wise initialization because the copy constructor initializes one object with the existing object, both belonging to the same class on a member by member copy basis.
The copy constructor can be defined explicitly by the programmer. If the programmer does not define the copy constructor, the compiler does it for us.
Copy constructor takes a reference to an object of the same class as an argument.

Sample(Sample &t)
{
    id=t.id;
}

class date
{
	int dd,mm,yy;
public:
	void show();
	date(int,int,int);
	date(date&);//copy constructor
};
 date::date(int d,int m,int y)
{
	dd=d;
	mm=m;
	yy=y;
}
 void date::show()
 {
	 cout<<"date is "<<dd<<"/"<<mm<<"/"<<yy<<endl;
 }
 date::date(date & d_new)
 {
	 this->dd=d_new.dd;
	 this->mm=d_new.mm;
	 this->yy=d_new.yy;
 }
int main()
{
	date d(8,8,17);
	date d1(d);
	d.show();
	d1.show();
}

#include<iostream>
#include<string.h>
using namespace std;
class student
{
    int rno;
    char name[50];
    double fee;
    public:
    student(int,char[],double);
    student(student &t)       //copy constructor
    {
        rno=t.rno;
        strcpy(name,t.name);
        fee=t.fee;
    }
    void display();
     
}; 
    student::student(int no,char n[],double f)
    {
        rno=no;
        strcpy(name,n);
        fee=f;
    }   
void student::display()
    {
        cout<<endl<<rno<<"\t"<<name<<"\t"<<fee;
    }
     
int main()
{
    student s(1001,"Manjeet",10000);
    s.display();
     
    student manjeet(s);   //copy constructor called
    manjeet.display();
     
    return 0;
}


Deep copy dynamically allocates the memory for the copy and then copies the actual value, both the source and copy have distinct memory locations. In this way, both the source and copy are distinct and will not share the same memory location. Deep copy requires us to write the user-defined constructor.
#include<iostream>
using namespace std;
class string1
{
	int len;
	char *ptr;
public:
	string1(char*);
	void stringdisplay();
	~string1();
	string1(string1&);
};
void string1::stringdisplay()
{
	cout<<"length is "<<len<<endl;
	cout<<"string is "<<ptr<<endl;
}
string1::string1(char * sptr)
{
	len=strlen(sptr);
	ptr=new char[len+1];
	strcpy(ptr,sptr);
}
string1::~string1()
{
	cout<<"destructor is called\n";
	if(ptr)
	delete [] ptr;
	ptr=NULL;
}
string1::string1(string1 & c)
{
	this->len=c.len;
	this->ptr=new char[this->len+1];
	strcpy(this->ptr,c.ptr);
}
int main()
{	
	string1 c2("rahul");
	c2.stringdisplay();
	string1 c3(c2);//copy constructor
	c3.stringdisplay();
	c2.~string1();
	c3.~string1();
}
=================================


When is a user-defined copy constructor needed? 
If we don’t define our own copy constructor, the C++ compiler creates a default copy constructor for each class which does a member-wise copy between objects. The compiler-created copy constructor works fine in general. 
If a class contains one of its data member as a pointer, its is mandatory on programmer's part to write user defined copy constructor.
user defined copy constructor should take care of dangling pointer situation.
in user defined copy constructvor, the object should be passed by reference to avoid infinite recursion of the copy constructor. 
  

Why argument to a copy constructor must be passed as a reference? 
A copy constructor is called when an object is passed by value. Copy constructor itself is a function. So if we pass an argument by value in a copy constructor, a call to the copy constructor would be made to call the copy constructor which becomes a non-terminating chain of calls. Therefore compiler doesn’t allow parameters to be passed by value.

When is the copy constructor called? 
In C++, a Copy Constructor may be called in the following cases: 

1)When an object of the class is returned by value.
 ==>If a function is returning an object by value,
a)A temporary object is automatically created by invoking the copy constructor,This temporary object holds the state of the returned object.
b)Destrutor is invoked for destroying the local object
c)temporary object is returned to the caller function and is assigned memberwise(shallow copy) to the object in the caller.
d)after assignment,this temporary object is destroyed.

ex:
cdate func()
{
cdate d(1,1,2001);
return d;
}
int main()
{
cdate d1;
d1=func();
}
//donot return local objects either by referece or pointer as it would lead to unpredictable results.

2)When an object of the class is passed (to a function) by value as an argument. 
void func(complex cobj)
{
int x=cobj.getreal();
}
int main()
{
complex c1(1,2);
func(c1);
}
==>If an object is passed by value mechanism,a copy of the object is created by invoking copy constructor of the class.
func() is a function to which an object of complex class is passed by value.In main() call is made to func() by passing c1 by value. cobj is created on stack exactly like c1 object by invoking compilers's copy constructor, as there is no user defined copy constructor written for complex. When the control returns from func() to main(),cobj is destroyed.

To avoid calls to copy constructor and destructor.It is preferred to pass the objects to function by reference. This also avoids memory wastage.

3)When an object is constructed based on another object of the same class. 

================================================================
// C++ program to implement the deep copy
#include <iostream>
using namespace std;
class box {
private:
    int length;
    int* breadth;
    int height;
 
public:
    // Constructor
    box()
    {
        breadth = new int;
    }
 
    // Function to set the dimensions
    // of the Box
    void set_dimension(int len, int brea,
                       int heig)
    {
        length = len;
        *breadth = brea;
        height = heig;
    }
 
    // Function to show the dimensions
    // of the Box
    void show_data()
    {
        cout << " Length = " << length
             << "\n Breadth = " << *breadth
             << "\n Height = " << height
             << endl;
    }
 
    // Parameterized Constructors for
    // for implementing deep copy
    box(box& sample)
    {
        length = sample.length;
        breadth = new int;
        *breadth = *(sample.breadth);
        height = sample.height;
    }
 
    // Destructors
    ~box()
    {
        delete breadth;
    }
};
 
// Driver Code
int main()
{
    // Object of class first
    box first;
 
    // Set the dimensions
    first.set_dimension(12, 14, 16);
 
    // Display the dimensions
    first.show_data();
 
    // When the data will be copied then
    // all the resources will also get
    // allocated to the new object
    box second = first;
 
    // Display the dimensions
    second.show_data();
 
    return 0;
}

Shallow Copy
The default copy constructor can only produce the shallow copy.
A Shallow copy is defined as the process of creating the copy of an object by copying data of all the member variables as it is.In shallow copy, the two objects are not independent. 	In deep copy, the two objects are  independent. 

Deep Copy
Deep copy dynamically allocates the memory for the copy and then copies the actual value, both the source and copy have distinct memory locations. In this way, both the source and copy are distinct and will not share the same memory location. Deep copy requires us to write the user-defined constructor.
=============================================================================

Destructor

==>While creating an object some resource may be acquired such as a file,database connection.to release these resource ,a function should be invoked implictly when an object is destroyed.this function is called as destructor.

Destructor is an instance member function that is invoked automatically whenever an object is going to be destroyed or explicitly deleted by delete operator.Meaning, a destructor is the last function that is going to be called before an object is destroyed.

A destructor is also a special member function like a constructor. Destructor destroys the class objects created by the constructor. 
Destructor has the same name as their class name preceded by a tilde (~) symbol.
It is not possible to define more than one destructor hence destructor can not be overloaded.
Destructor neither requires any argument nor returns any value.
It is automatically called when an object goes out of scope. 
Destructor release memory space occupied by the objects created by the constructor.
In destructor, objects are destroyed in the reverse of an object creation.

The thing is to be noted here if the object is created by using new or the constructor uses new to allocate memory that resides in the heap memory or the free store, the destructor should use delete to free the memory.   

The syntax for defining the destructor within the class:

~ <class-name>() {
    // some instructions
}
The syntax for defining the destructor outside the class:

<class-name> :: ~<class-name>() {
    // some instructions
}

// C++ program to demonstrate the execution of constructor and destructor
 
#include <iostream>
using namespace std;
 class Test {
public:
    // User-Defined Constructor
    Test() { cout << "\n Constructor executed"; }
 
    // User-Defined Destructor
    ~Test() { cout << "\nDestructor executed"; }
};
main()
{
    Test t;
}


// C++ program to demonstrate the execution of constructor and destructor when multiple objects are created
 #include <iostream>
using namespace std;
class Test {
public:
     Test() { cout << "\n Constructor executed"; }
 
    ~Test() { cout << "\n Destructor executed"; }
};
 main()
{
    // Create multiple objects of the Test class
    Test t, t1, t2, t3;
}

// C++ program to demonstrate the number of times constructor and destructors are called
 
#include <iostream>
using namespace std;
static int Count = 0;     
class Test {
public:
 
    Test()
    { 
        // Number of times constructor is called
        Count++;
        cout << "No. of Object created: " << Count<< endl;
    }
     ~Test()
    {
         
        cout << "No. of Object destroyed: " << Count << endl;                                  
        Count--;
        // Number of times destructor is called
    }
};
int main()
{
    Test t, t1, t2, t3;
}
Output

No. of Object created: 1
No. of Object created: 2
No. of Object created: 3
No. of Object created: 4
No. of Object destroyed: 4
No. of Object destroyed: 3
No. of Object destroyed: 2
No. of Object destroyed: 1
Note: Objects are destroyed in the reverse order of their creation. In this case, t3 is the first to be destroyed, while t is the last.

Properties of Destructor
The destructor function is automatically invoked when the objects are destroyed.
It cannot be declared static or const.
The destructor does not have arguments.
It has no return type not even void.
 It can be defined only once in a class
destructor only deinitializes the object and doesnot dealloacte the memory.
destructor cannot be made private.
========================================================================================
How to call destructors explicitly?
We can call the destructors explicitly using the following statement:

object_name.~class_name()

When do we need to write a user-defined destructor?
If we do not write our own destructor in class, the compiler creates a default destructor for us. The default destructor works fine unless we have dynamically allocated memory or pointer in class. When a class contains a pointer to memory allocated in the class, we should write a destructor to release memory before the class instance is destroyed. This must be done to avoid memory leaks.

Ex:
class cstring
{
	public:
	~cstring()
	{
		if(ptr)
		{
			delete[] ptr;
			ptr=NULL;
		}
	}
};

==>The pointer ptr is checked to confirm that it is not NULL before memory on heap is deleted.
It is not always mandatory to write userdefined destructor in the class.This function is basically used for cleanup purpose.The destructor implemented to free the memory pointed by ptr. otherwise the memory remains allocated even though the pointer data member pointing to it goes out of scope when the object is destroyed. This is typical problem of memory leakage.If a class contains a pointer as a datamember , then it is mandatory for the programmer to implement a destructor.

#include <iostream>
using namespace std;
 class String {
private:
    char* s;
    int size;
 public:
    String(char*); // constructor
    ~String(); // destructor
};
 String::String(char* c)
{
    size = strlen(c);
    s = new char[size + 1];
    strcpy(s, c);
}
String::~String() { 
    cout<<"dest called";
    delete[] s;
    }
 
int main()
{
    String str("Hello, World!");
}
=======================================================
Scope of an Object
class Test
{
	public:
	Test()
	{
		cout<<"constructor is invoked";
	}
	~Test()
	{
		cout<<"destructor is invoked";
	}
};
Test t1;
int main()
{
	cout<<"main begins";
	Test t2;
	{
		cout<<"block begins"<<endl;
		Test t3
		cout<<"block ends"<<endl;
	}
	cout<<"main ends"<<endl;
}

The sequence of the constructor calls and the destructor calls of all the objects created is determined according to the life of the objets.
output:

constructor is invoked
main begins
constructor is invoked
block begins
constructor is invoked
block ends
destructor is invoked
main ends
destructor is invoked
destructor is invoked
==========================================================================
===================================================================================
===================================================================================
Inheritance:

==>The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object-Oriented Programming. 

==>Inheritance is a feature or a process in which, new classes are created from the existing classes. The new class created is called "derived class" or "child class" and the existing class is known as the "base class” or “parent class”. The derived class now is said to be inherited from the base class.

==>When we say derived class inherits the base class, it means, the derived class inherits all the properties of the base class, without changing the properties of base class and may add new features to its own. These new features in the derived class will not affect the base class. The derived class is the specialized class for the base class.

==>It not only helps to reuse the old code but adds in extendings the functionality. i.e Reusability + Extensibility
Reusability:
Once a class is written and tested,it can be further used for creating new classes.These derived classes not only inherit the features of their base class,but also have their own individualist features. Tjos means that if the derived class wants to use its base class properties,it can do so because those properties are also available to the deried class by the virtue of inheritance.Now you can reuse the members of your parent class. So, there is no need to define the member again. So less code is required in the class.

Extensibility:
It is the mechanism of being able to derive classes from existing classes that provides extensibility of adding and removing classes in a hierarchy as and when required.Any changes to data or functionalities contained within a base class are immediately inherited by all derived classes.

==>each child has "is a " relationship with its parent.

==>Sub Class: The class that inherits properties from another class is called Subclass or Derived Class. 
Super Class: The class whose properties are inherited by a subclass is called Base Class or Superclass.


Implementing inheritance in C++: For creating a sub-class that is inherited from the base class we have to follow the below syntax. 
Derived Classes: A Derived class is defined as the class derived from the base class.
Syntax: 

class  <derived_class_name> : <access-specifier> <base_class_name>
{
        //body
}
Where
class      — keyword to create a new class
derived_class_name   — name of the new class, which will inherit the base class
access-specifier  — either of private, public or protected. If neither is specified, PRIVATE is taken as default
base-class-name  — name of the base class

There are three Access specifiers in C++. These are:

Access Modifiers or Access Specifiers in a class are used to assign the accessibility to the class members.
Note: If we do not specify any access modifiers for the members inside the class, then by default the access modifier for the members will be Private.

public – members are accessible from outside the class, and members can be accessed from anywhere.
 The data members and member functions declared as public can be accessed by other classes and functions too.
The public members of a class can be accessed from anywhere in the program using the direct member access operator (.) with the object of that class. 
// C++ program to demonstrate public
// access modifier
 
#include<iostream>
using namespace std;
 
// class definition
class Circle
{
    public: 
        double radius;
         
        double  compute_area()
        {
            return 3.14*radius*radius;
        }
     
};
 
// main function
int main()
{
    Circle obj;
     
    // accessing public datamember outside class
    obj.radius = 5.5;
     
    cout << "Radius is: " << obj.radius << "\n";
    cout << "Area is: " << obj.compute_area();
    return 0;
}
Output: 

Radius is: 5.5
Area is: 94.985
In the above program, the data member radius is declared as public so it could be accessed outside the class and thus was allowed access from inside main(). 
 
======================================================================================
===============================================================================================
private – members cannot be accessed (or viewed) from outside the class, i.e members are private to that class only.
The class members declared as private can be accessed only by the member functions inside the class. They are not allowed to be accessed directly by any object or function outside the class. Only the member functions or the friend functions are allowed to access the private data members of the class.

// C++ program to demonstrate private
// access modifier
 
#include<iostream>
using namespace std;
 
class Circle
{   
    // private data member
    private: 
        double radius;
      
    // public member function    
    public:    
        double  compute_area()
        {   // member function can access private 
            // data member radius
            return 3.14*radius*radius;
        }
     
};
 
// main function
int main()
{   
    // creating object of the class
    Circle obj;
     
    // trying to access private data member
    // directly outside the class
    obj.radius = 1.5;
     
    cout << "Area is:" << obj.compute_area();
    return 0;
}
The output of the above program is a compile time error because we are not allowed to access the private data members of a class directly from outside the class. Yet an access to obj.radius is attempted, but radius being a private data member, we obtained the above compilation error. 

However, we can access the private data members of a class indirectly using the public member functions of the class. 
=========================================================================================
protected – members cannot be accessed from outside the class, but, they can be accessed in inherited classes or derived classes. The protected access modifier is similar to the private access modifier in the sense that it can’t be accessed outside of its class unless with the help of a friend class. The difference is that the class members declared as Protected can be accessed by any subclass (derived class) of that class as well.

// C++ program to demonstrate protected access modifier
#include <iostream>
using namespace std;
 class Parent
{   
    protected:
    int id_protected;
  };
class Child : public Parent
{
    public:
    void setId(int id)
    { 
        // Child class is able to access the inherited protected data members of base class
             id_protected = id;
      }
       void displayId()
    {
        cout << "id_protected is: " << id_protected << endl;
    }
};
 int main() {
     
    Child obj1;
  // member function of the derived class can access the protected data members of the base class
  obj1.setId(81);
    obj1.displayId();

}
Output: 

id_protected is: 81
=============================================================================================
Note:
When derived class obj is created memory is allocated for base class datamembers as well as for derived class data members. Through derived class obj, we can access base class members except private as well as derived class members.
// C++ program to demonstrate implementation of Inheritance
 #include <bits/stdc++.h>
using namespace std;
class Parent {
public:
    int id_p;
};
class Child : public Parent {
public:
    int id_c;
};
 int main()
{
    Child obj1;
 
    // An object of class child has all data members and member functions of class parent
    obj1.id_c = 7;
    obj1.id_p = 91;
    cout << "Child id is: " << obj1.id_c << '\n';
    cout << "Parent id is: " << obj1.id_p << '\n';
    cout<<sizeof(obj1);
}

Note 2:
When base class obj is created memory is allocated for base class datamembers only. Through base class obj, we can access base class members only ,we cannot access derived class members.

#include <bits/stdc++.h>
using namespace std;
class Parent {
public:
    int id_p;
};
class Child : public Parent {
public:
    int id_c;
};
 int main()
{
    Parent obj1;
 
    // An object of class child has all data members and member functions of class parent
   // obj1.id_c = 7;//error
    obj1.id_p = 91;
   // cout << "Child id is: " << obj1.id_c << '\n';//error
    cout << "Parent id is: " << obj1.id_p << '\n';
    cout<<sizeof(obj1);
}

==============================================================================================
Modes of Inheritance: There are 3 modes of inheritance.

Modes of inheritance specifies the way in which a class is derived. It tells abouth the access rights given to the derived class to access its base class attributes and functions. These mode are:
private(default)
public
protected

ex:
class derived_class_name :: visibility-mode base_class_name  
{  
    // body of the derived class.  
}  
Where,
derived_class_name: It is the name of the derived class.
visibility mode: The visibility mode specifies whether the features of the base class are publicly inherited or privately inherited. It can be public or private.

Example:
1. class ABC : private XYZ              //private derivation
            {                }
2. class ABC : public XYZ              //public derivation
            {               }
3. class ABC : protected XYZ              //protected derivation
            {              }
4. class ABC: XYZ                            //private derivation by default
{            }


Public Mode: If we derive a subclass from a public base class. Then the public member of the base class will become public in the derived class and protected members of the base class will become protected in the derived class.
1. C++ public Inheritance
In this example, public inheritance is demonstrated. Since private and protected members will not be directly accessed from main( ) so we have had to create functions name getPVT( ) to access the private variable and getProt( ) to access the protected variable from the inherited class.

Example:


// C++ program to demonstrate the working of public 
// inheritance 
#include <iostream> 
using namespace std; 
  
class Base { 
private: 
    int pvt = 1; 
protected: 
    int prot = 2; 
  
public: 
    int pub = 3; 
  
    // function to access private member 
    int getPVT() { return pvt; } 
}; 
  
class PublicDerived : public Base { 
public: 
    // function to access protected member from Base 
    int getProt() { return prot; } 
}; 
  
int main() 
{ 
    PublicDerived object1; 
    cout << "Private = " << object1.getPVT() << endl; 
    cout << "Protected = " << object1.getProt() << endl; 
    cout << "Public = " << object1.pub << endl; 
    return 0; 
}
Output
Private = 1
Protected = 2
Public = 3

Protected Mode: If we derive a subclass from a Protected base class. Then both public members and protected members of the base class will become protected in the derived class.

We know that protected members can only be accessed from the Derived class. These members cannot be directly accessed from outside the class. So we cannot use getPVT() from ProtectedDerived.This is also why we need to create getPub() function in the Derived class in order to access the pub variable.

Example:


// C++ program to demonstrate the working 
// of protected inheritance 
#include <iostream> 
using namespace std; 
  
class Base { 
private: 
    int pvt = 1; 
  
protected: 
    int prot = 2; 
  
public: 
    int pub = 3; 
  
    // function to access private member 
    int getPVT() { return pvt; } 
}; 
  
class ProtectedDerived : protected Base { 
public: 
    // function to access protected member from Base 
    int getProt() { return prot; } 
  
    // function to access public member from Base 
    int getPub() { return pub; } 
}; 
  
int main() 
{ 
    ProtectedDerived object1; 
    cout << "Private cannot be accessed." << endl; 
    cout << "Protected = " << object1.getProt() << endl; 
    cout << "Public = " << object1.getPub() << endl; 
    return 0; 
}
Output
Private cannot be accessed.
Protected = 2
Public = 3


Private Mode: If we derive a subclass from a Private base class. Then both public members and protected members of the base class will become Private in the derived class.
Note: The private members in the base class cannot be directly accessed in the derived class, while protected members can be directly accessed.

/ C++ program to demonstrate the working 
// of private inheritance 
#include <iostream> 
using namespace std; 
  
class Base { 
private: 
    int pvt = 1; 
  
protected: 
    int prot = 2; 
  
public: 
    int pub = 3; 
  
    // function to access private member 
    int getPVT() { return pvt; } 
}; 
  
class PrivateDerived : private Base { 
public: 
    // function to access protected member from Base 
    int getProt() { return prot; } 
  
    // function to access private member 
    int getPub() { return pub; } 
}; 
  
int main() 
{ 
    PrivateDerived object1; 
    cout << "Private cannot be accessed." << endl; 
    cout << "Protected = " << object1.getProt() << endl; 
    cout << "Public = " << object1.getPub() << endl; 
    return 0; 
}
Output
Private cannot be accessed.
Protected = 2
Public = 3
===================================================================================================
When the base class is privately inherited by the derived class, public members of the base class becomes the private members of the derived class. Therefore, the public members of the base class are not accessible by the objects of the derived class only by the member functions of the derived class.

ex:


#include<iostream>
using namespace std;
class A
{
	int c;
public:
	int a;
protected:
	int b;
public:
	void display()
	{
		cout<<"in display of A\n";
	}
};
class B:private A
{
public:
	int c;
public:
	void show()
	{
	    display();//allowed
		cout<<a<<b;
	}
};
class C:private B
{
	public:
	void show()
	{
	   // display(); not allowed
		//cout<< a<<b; not allowed
		cout<<c;
	}
};
int main()
{
	B bobj;
	bobj.show();
//	bobj.display(); not allowed
}
In the above example, class A is privately inherited. Therefore, the display() function of class 'A' cannot be accessed by the object of class B. It can only be accessed by the member function of class B.

How to make a Private Member Inheritable
The private member is not inheritable. If we modify the visibility mode by making it public, but this takes away the advantage of data hiding.
C++ introduces a third visibility modifier, i.e., protected. The member which is declared as protected will be accessible to all the member functions within the class as well as the class immediately derived from it.

====================================================================================
When the base class is publicly inherited by the derived class, public members of the base class also become the public members of the derived class. Therefore, the public members of the base class are accessible by the objects of the derived class as well as by the member functions of the derived class.

#include<iostream>
using namespace std;
class A
{
	int c;
public:
	int a;
protected:
	int b;
public:
	void display()
	{
		cout<<"in display of A\n";
	}

};
class B:public A
{
public:
		public:
	void show()
	{
	    display();
		cout<<a<<b;
	}
};
class C:public B
{
	public:
	void show()
	{
		cout<< a<<b;
			}
};
int main()
{
	B bobj;
	bobj.show();
	bobj.display();
}
=====================================================================
When the base class is protectedly inherited by the derived class, the public members of the base class are not accessible by the objects of the derived class (because public members of base class becomes protected in derived class and protected datamember cannot be accessed outside the class) only by the member functions of the derived class.

#include<iostream>
using namespace std;
class A
{
int c;
public:
	int a;
protected:
	int b;
protected:
	void display()
	{
		cout<<"in display of A\n";
	}

};
class B:protected A
{
public:
	int d;
	public:
	void show()
	{
	    	B bobj;
	bobj.display();
		cout<<a<<b;
	
	}
};

int main()
{
    B bobj;
    bobj.show();
}
==================================================================================
Types Of Inheritance
C++ supports five types of inheritance:

Single inheritance
Multiple inheritance
Hierarchical inheritance
Multilevel inheritance
Hybrid inheritance

C++ Single Inheritance
Single inheritance is defined as the inheritance in which a derived class is inherited from the only one base class.

#include <iostream>  
using namespace std;  
 class Account {  
   protected:  
   float bonus = 2000;   
 };  
   class Programmer: public Account {  
   public:  
   float monthly_salary = 5000;  
   void CalculateSalary()
   {
       cout<<"Total Salary: "<<monthly_salary+bonus<<endl;    
   }
   };       
int main() {  
     Programmer p1;  
     p1.CalculateSalary();
        
    return 0;  
}  
=========================================================================
While creating an object of the derived class, the base class constructor is called first and then the derived class constructor is called. The base class constructor is responsible for initializing the inherited data members and the derived class constructor is responsible for initializing data members of derived class.

The member initializer list is used to indicate which base class constructor to call in the derived class constructor.otherwise , the no argument constructor of base class is used.

Derived object has two partss: a base part and a derived part.
The base part of derived object is constructed first. then the derived part is constructed. therefore the constructor calls are in the order of base->derived.


Why the base class’s constructor is called on creating an object of derived class?

 What happens when a class is inherited from other? The data members and member functions of base class comes automatically in derived class based on the access specifier but the definition of these members exists in base class only. So when we create an object of derived class, all of the members of derived class must be initialized but the inherited members in derived class can only be initialized by the base class’s constructor as the definition of these members exists in base class only. This is why the constructor of base class is called first to initialize all the inherited members. 



/*#include<iostream>
using namespace std;
class A
{
	int a;
public:
	A();
    void display();
 };
A::A()
{
	cout<<"in default of A\n";
	a=10;
}
void A::display()
{
	cout<<a<<endl;
}
class B:public A
{
	int b;
public:
	B();
	void display();
};
B::B()
{
	cout<<"in default of B\n";
	b=20;
}
void B::display()
{
	A::display();
	cout<<b<<endl;
}
int main()
{
	B bobj;
	bobj.display();
}

#include<iostream>
using namespace std;
class A
{
	int a;
public:
	A(int);
    void display();
 };
A::A(int p)
{
	cout<<"in para of A\n";
	a=p;
}
void A::display()
{
	cout<<a<<endl;
}
class B:public A
{
	int b;
public:
	B(int,int);
	void display();
};
B::B(int p,int q):A(p)//base class initilization list
{
	cout<<"in para of B\n";
	b=q;
}
void B::display()
{
	A::display();
	cout<<b<<endl;
}
int main()
{
	B bobj(10,20);
	bobj.display();
}
Important Points: 

Whenever the derived class’s default constructor is called, the base class’s default constructor is called automatically.
To call the parameterized constructor of base class inside the parameterized constructor of sub class, we have to mention it explicitly.
The parameterized constructor of base class cannot be called in default constructor of sub class, it should be called in the parameterized constructor of sub class.
=============================================================================================
Multilevel Inheritance

Multilevel Inheritance in C++ is the process of deriving a class from another derived class. When one class inherits another class it is further inherited by another class. It is known as multi-level inheritance.

For example, if we take Grandfather as a base class then Father is the derived class that has features of Grandfather and then Child is the also derived class that is derived from the sub-class Father which inherits all the features of Father.
class A // base class
{
    ...........
};
class B : access_specifier A // derived class
{
    ...........
} ;
class C : access_specifier B // derived from derived class B
{
    ...........
} ;

// C++ program to implement constructor in multilevel   Inheritance 
#include<iostream> 
using namespace std; 
  
// Base class 
class A 
{ 
    public: 
        A() 
        { 
            cout << "Base class A constructor \n"; 
        } 
}; 
  
// Derived class B 
class B: public A 
{ 
    public: 
        B() 
        { 
            cout << "Class B constructor \n"; 
        } 
}; 
  
// Derived class C 
class C: public B 
{ 
    public: 
        C() 
        { 
            cout << "Class C constructor \n"; 
              
        } 
}; 
  
// Driver code 
int main() 
{ 
    C obj; 
    return 0; 
}

==================================================================
class employee
{
	int id;
public:
	employee();
	employee(int);
     void display();
	 int findsalary()
	{
		return 0;
	}
};
employee::employee()
{
	cout<<"in default of emp\n";
	id=0;
}
employee::employee(int i)
{
	cout<<"in para of emp\n";
	id=i;
}
void employee::display()
{
	
	cout<<"id of an emp is "<<id<<endl;
}

class wageemployee:public employee
{
	int hrs,rate;
public:
	wageemployee();
	wageemployee(int,int,int);
	 void display();
int findsalary();
};
wageemployee::wageemployee()
{
	cout<<"in default of wage\n";
	hrs=0;
	rate=0;
}
wageemployee::wageemployee(int i,int h,int r)
	:employee(i)
{
	cout<<"in para of wage\n";
	hrs=h;
	rate=r;
}
int wageemployee::findsalary()
{
	return hrs * rate;
}
void wageemployee::display()
{
	employee::display();
	cout<<hrs<<endl;
	cout<<rate<<endl;
}
class salesmanager:public wageemployee
{
	int sales,comm;
public:
	salesmanager();
	salesmanager(int,int,int,int,int);
	void display();
	int findsalary();
	void show();
};
salesmanager::salesmanager()
{
	cout<<"in default of sales\n";
	sales=comm=0;
}
salesmanager::salesmanager(int i,int h,int r,int s,
	int c):wageemployee(i,h,r)
{
	cout<<"in para of sales\n";
	sales=s;
	comm=c;
}
void salesmanager::display()
{
	wageemployee::display();
	cout<<"sales of an emp is "<<sales<<endl;
	cout<<"comm of an emp is  "<<comm<<endl;
}
int salesmanager::findsalary()
{
	return wageemployee::findsalary()  + sales * comm;
}
void salesmanager::show()
{
	cout<<"in show fun\n";
}
int main()
{
	salesmanager *ptr=new salesmanager();
	cout<<"salary is "<<ptr->findsalary();
	ptr->display();
	
}
=================================================================
Destructors in C++ are called in the opposite order of that of Constructors.
============================================================================================
Function Overriding
1)two or more function having same function name and same signature and same return type is called as function overriding
2)overrided function  must be present in inherited classes i.e scopes are different

Generic Pointer
1)Generic pointer is that pointer which will hold the address of base class object or it can hold the address of derived class object.

Polymorphism

polymorphism is made up of 2 words poly means many and morphism means forms, so polymorphism means many forms.
it means identically " one name " named methods(member functions) that have different behaiour means one methodss have multiple forms.Same message is pass to inherited classes and this classes will respond to the same message in different ways by  is called as polymorphism


Binding is the process of associating a function call to an object.
Different types of polymorphism are as follows
1)compile time polymorphism:
When binding occurs at compile time,it is known as compile time binding. All the methods are called on object at compile time. In compile-time polymorphism, the compiler determines which function or operation to call based on the number, types, and order of arguments. 
This kind of polymorphism is implemented using function overloading and operator overloading.such polymorphism is called as early binding or static binding because an object is bound to its function call at compile time.
==>At compile time,compiler will check the type of pointer rather than the type of data.



2)Runtime polymorphism:
When the binding process occurs at runtime ,it is called as runtime binding.
In order to invoke the appropriate function of the derived class,the compiler needs to bind that function call to the correct function defination.The decision of which function to be invoked is taken at a later stage(at runtime). Hence this feature is referred to as runtime binding.The generic pointer is capable of pointing to any object at runtime. hence it can invoke any function dynamically depending on the type of the object that it is pointing to . In run-time polymorphism, the decision of which function to call is determined at runtime based on the actual object type rather than the reference or pointer type. It is also known as Dynamic Polymorphism
Run Time Polymorphism can be exhibited by:

Method Overriding using Virtual Functions
Method Overriding
Method overriding refers to the process of creating a new definition of a function in a derived class that is already defined inside its base class. Some rules that must be followed while overriding a method are:
Method names must be the same.
Method parameters must be the same.

Virtual Function
Virtual Function is a member function that is declared as virtual in the base class and it can be overridden in the derived classes that inherit the base class.

Difference Between Compile Time And Run Time Polymorphism
Compile-Time Polymorphism and Run-Time Polymorphism

1)It is also called Static Polymorphism.	It is also known as Dynamic Polymorphism.
2)In compile-time polymorphism, the compiler determines which function or operation to call based on the number, types, and order of arguments.	In run-time polymorphism, the decision of which function to call is determined at runtime based on the actual object type rather than the reference or pointer type.
3)The function to be invoked is known at the compile time.	The function to be invoked is known at the run time.
4)Compile-time Polymorphism can be exhibited by: Function Overloading and Operator Overloading
Run-time Polymorphism can be exhibited by Function Overriding.
5)Faster execution rate.	Comparatively slower execution rate.
6)Inheritance in not involved.	Involves inheritance.
=============================================
Virtual Function
==>Polymorphism provides a way for the derived class to give its own defination of a method that has already been defined by the base class.This process is called as method overriding.To implement late binding, the function is declared with the keyword virtual in the base class.
==>To implement late binding, the function is declared with the keyword virtual in the base class. usually, when there is a possibility that a function in the base class may be overridden in the derived class this function is marked as virtual.
The function in the derived class is overridden with same signature and return type.
==>Polymorphism relies on runtime binding.To achieve runtime binding virtual keyword should be used.virtual keyword will tell the compiler to do binding at runtime and not at compile time.
==>It tells the compiler to perform late binding where the compiler matches the object with the right called function and executes it during the runtime. This technique falls under Runtime Polymorphism.

1)virtual function is a member function that can be redefined for the derived classes.
2)The function in the base class,which are overridden  in the subsequent derived classes, are also considered virtual by the compiler.virtual function is redefined in all the derived classes even if the virtual keyword is not written.
3)constructors can not be made Virtual Function
4)destructor can be made Virtual Function
5)virtual keyword should not be written in definition

**At runtime binding the compiler will check the type of data rather than the type of pointer.According to the type of data the compiler will invoke the function of that class.
**The idea is that virtual functions are called according to the type of the object instance pointed to or referenced, not according to the type of the pointer or reference.
In other words, virtual functions are resolved late, at runtime.

================================================================================================
==>A base class pointer can point to derived class object without needing a cast. This is termed as up-casting. Derived object can be assigned to base object without any casr but the reverse is not true.

Compile time binding
Employee * ptr,e1;
Salesperson sp1;
ptr=&e1;
ptr=&sp1;
ptr->computesalary();

==>Compiler tries to find computesalary() in Employee class and not in Salesperson (though ptr is pointing to sp1  object of Salesperson class).The reason is that the compiler selects the member function according to the type of pointer rather than the type of object being pointed to. The compiler tries to govern the method invocation using compiletime or static type binding of the generic pointer, which is of type Employee .
==>so, the above call to computesalary() is resolved by the compiler as Employee::computesalary(), even when the pointer is actually pointing to Salesperson object.
==>If the  Employee class doesnot have computesalary() . This results in a compile-time error as computesalary() is not a member of the class Employee.

Need of Type-Casting

Inorder to invoke the function by the type of the object whose address it is holding, there is a need to typecast the generic pointer to the required type. It typecast the generic pointer ptr to salesperson classtype.Then the computesalary() of salesperson class is invoked. so, depending on which computesalary() to call,employee pointer is typecasted to the particular datatype.
Employee* ptr;
switch(ptr)
{
	case 1:(wageemployee*) ptr->computesalary();
	case 2:(salesperson*) ptr->computesalary();
}

Drawbacks of Typecasting
1)If a new category of employee named clerk is added in the hieracrchy,changes have to be made in the above source code by adding a new case where the generic pointer can be typecast to the category clerk.It becomes practically infeasible from the maintenance point of view to alter the source code every time the application is extended to add a new category of employees.

2)The function that is invoked need not be an overriden function. After the generic pointer is typecast to any derived class type,it always invokes the function of that derived class irrespective of the contents of the pointer.

Employee * ptr;
static_cast<salesperson*>(ptr->somespecificfunction());
somespecificfunction is a specific function of salesperson class. here ptr doesnot hold the address of any salesperson object but still it can invoke the function that belongs to the salesperson class specifically.

To resolve these problems,virtual function are used.

==>C++ supports polymorphism by allowing member functions defined in baseclass to be overridden. When these functions are made virtual in the base class and are invoked using generic pointer, then dynamic datatypes of thos pointer is checked i.e the type of the object it points to at runtime.

==>If the function is non virtual,static type of pointer is checked and accordingly the member function of the baseclass is invoked

Points on virtual function:
1)keyword virtual can be used only in context with overriden function.That is ,if computesalary() is not declared in the class Employee, then the compilee will flash an error.
computesalry() is not the member of the class Employee
2)Specific functions of the derived class cannot be called using generic pointer.
ptr->somespecificfunction()
somespecificfunction() is a specific function of salesperson class. Since this function is non virtual, compile time binding will takes place. static type of the pointer will be considered by the compiler to resolve this call.Since this function is not present in the baseclass,compiler will give error.
3)Virtual functions must be non static member functions of the class since the virtual function mechanism relies on the specific object to determine which implementation of the function should be called. This is not possible for static function because they donot work with objects of the class and hence they cannot be declared as virtual.
4)Virtual functions cannot be friend function.Friend function are not members of the base class and hence cannot be inherited or overrided.
5)Functions that are overriden in the derived class are declared as virtual in the base class. since the base class pointer is used to invoke the appropriate function at runtime.
6)Constructors cannot be made virtual .When an object of a derived class is created, base class constructor should be called first.But if th base class constructor is made virtual, the derived class constructor wil be directly called and the base class members will not be initialized. Therefore forseeing the problem,compiler doesnot allow virtaul constructors.
7)If a function is declared as virtual in the base class then,it will be treated as virtual in derived class even if the keyword virtual is not used.

=======================================================================================
Pure virtual function
1)A function without executable code is called as Pure virtual function.declared by using a specifier(=0) in the declaration of a virtual member function in the class declaration
2) Pure virtual function is represented by(=0) in the function declaration and not in the definition
ex:virtual float computesalary()=0;
3)A class contains atleast 1 pure virtual function than that class is called as abstact class
4)if any class contain all the pure virtual function then that class is calles as pure abstract  class
5)we can not create object of an abstract class
6)however we can create pointer  of an abstract class.
7)if any base class contains pure virtual function then the pure virtual function has to be overrided in the derived class and give the implementation according to the requirements
8)Abstract class supports runtime polymorphism.
9)if Pure virtual function is not overrided in the derived class than the derived class should be declared as abstract.
10)If a class is too generic to define its object then the class is made abstract.so the sole purpose of abstract classes is to provide a baseclass for other classes.
11)An abstract class can have constructors. 

Sometimes implementation of all functions cannot be provided in a base class because we don’t know the implementation. Such a class is called an abstract class.For example, let Shape be a base class. We cannot provide the implementation of function draw() in Shape, but we know every derived class must have an implementation of draw().other methods can be pure virtual function or virtual function or concrete funtion.
ex: shape is a base class which is abstract.several other classes like circle,rectangle can be derived from it. The common attributes and behaviour of all shapes are bundled together in shape class. draw() and area() are the two common behaviours of all the abobe mentioned shapes.
==>A shape hierarchy may define abstract class that requires programmers using it to provide their own implementation of the class by creating a derived class. This hierarchy is easily extensible.

ex:
In class Employee,computesalary() was added to implement runtime polymorphism.
float computesalary()
{
	return 0.0f;
}
Actually this implementation is unnecessary and does not ake any sense. This function is never called ,but its existence in the class Employee is necessary to enable polymorphism.
==>If a virtual function doesnot contain any meaningful code or if it has been added merly to ahieve dynamic binding,then it is made pure virtual funtion.

Why Destructorcan be made virtual?
class A
{
	public :
	~A()
	{
		cout<<"In A's Destructor";
	}
};
class B :public A
{
	public :
	~B()
	{
		cout<<"In B's Destructor";
	}
};
int main()
{
A * aptr=new B();
delete aptr;
}

==If a base class pointer points to a derived object created on heap and the memory is freed by delete with base pointer the base class destructor is called.The deried class destructor is not invoked at all. To resole this problem,the base class destructor is made virtual.
ex:
Class A is a base class and B is derived from A. The destructor is made virtual in class A and an object of class B is created on heap using new and the address is stored in the base class A pointer i.e aptr.For the statement delete aptr, the destructor for the derived class is invoked first.
==If the destructor is not made virtual, the base class destructor is called directly without the derived class destructor being called first. This leads to memory related problems.
=======================================================================
Destructor can also be pure virtual.

Can a destructor be pure virtual in C++? 
Yes, it is possible to have a pure virtual destructor. Pure virtual destructors are legal in standard C++ and one of the most important things to remember is that if a class contains a pure virtual destructor, it must provide a function body for the pure virtual destructor. 

Why a pure virtual function requires a function body?

The reason is that destructors (unlike other functions) are not actually ‘overridden’, rather they are always called in the reverse order of the class derivation. This means that a derived class destructor will be invoked first, then the base class destructor will be called. If the definition of the pure virtual destructor is not provided, then what function body will be called during object destruction? Therefore the compiler and linker enforce the existence of a function body for pure virtual destructors. 

// C++ Program to demonstrate a pure virtual destructor
#include <iostream>
using namespace std;
 
// Initialization of base class
class Base {
public:
    virtual ~Base() = 0;
    // Pure virtual destructor
};
 
// Initialization of derived class
class Derived : public Base {
public:
    ~Derived() { cout << "~Derived() is executed"; }
};
 
// Driver Code
int main()
{
    // base class pointer which is
    // allocating fresh storage
    // for Derived function object's
    Base* b = new Derived();
    delete b;
    return 0;
}
The linker will produce the following error in the above program. 
undefined reference to `Base::~Base()'  error: ld returned 1 exit status
Now if the definition for the pure virtual destructor is provided, then the program compiles & runs fine.


// C++ program to demonstrate if the value of
// of pure virtual destructor are provided
// then the program compiles & runs fine.
 
#include <iostream>
 
// Initialization of base class
class Base {
public:
    virtual ~Base() = 0; // Pure virtual destructor
};
Base::~Base() // Explicit destructor call
{
    std::cout << "Pure virtual destructor is called";
}
 
// Initialization of derived class
class Derived : public Base {
public:
    ~Derived() { std::cout << "~Derived() is executed\n"; }
};
 
int main()
{
    // Calling of derived member function
    Base* b = new Derived();
    delete b;
    return 0;
}
Output
~Derived() is executed
Pure virtual destructor is called


==================================================================

Similarities between virtual function and pure virtual function
1)These are the concepts of Run-time polymorphism.
2)Prototype i.e. Declaration of both the functions remains the same throughout the program.
3)These functions can’t be static.

Difference between virtual function and pure virtual function in C++

1)A virtual function is a member function of base class which can be redefined by derived class.	A pure virtual function is a member function of base class whose only declaration is provided in base class and should be defined in derived class otherwise derived class also becomes abstract.
2)Classes having virtual functions are not abstract.	Base class containing pure virtual function becomes abstract.

3)Syntax:
 
virtual<func_type><func_name>() 
{ 
    // code 
} 
Syntax:
 
virtual<func_type><func_name>() 
    = 0; 

4)Definition is given in base class.	No definition is given in base class.
5)Base class having virtual function can be instantiated i.e. its object can be made.	Base class having pure virtual function becomes abstract i.e. it cannot be instantiated.
6)If derived class do not redefine virtual function of base class, then it does not affect compilation.	
If derived class do not redefine virtual function of base class, then no compilation error but derived class also becomes abstract just like the base class.
7)All derived class may or may not redefine virtual function of base class.
All derived class must redefine pure virtual function of base class otherwise derived class also becomes abstract just like base class.
=============================================================================
FAQ:What happens when a virtual function is called inside a non-virtual function in C++


#include <iostream>
using namespace std;
 class Base
{
public:
    void print()
    {
        cout << "Base class print function \n";
    }
    void invoke()
    {
        cout << "Base class invoke function \n";
        this -> print();
    }
};
 
class Derived: public Base
{
public:
    void print()
    {
        cout << "Derived class print function \n" ;
    }
    void invoke()
    {
        cout << "Derived class invoke function \n";
        this -> print();
    }
};
 
int main()
{
    Base *b = new Derived;
    b -> invoke();
    return 0;
}
Output:

Base class invoke function
Base class print function
Since there is no virtual function, run time polymorphic behavior doesn’t work in the above code. 


#include <iostream>
using namespace std;
 class Base
{
public:
    virtual void print()
    {
        cout << "Base class print function \n";
    }
    void invoke()
    {
        cout << "Base class invoke function \n";
        this -> print();
    }
};
 
class Derived: public Base
{
public:
    void print()
    {
        cout << "Derived class print function \n" ;
    }
    void invoke()
    {
        cout << "Derived class invoke function \n";
        this -> print(); // called under non - virtual function
    }
};
 
int main()
{
    Base *b = new Derived;
    b -> invoke();
    return 0;
}
Output:


Base class invoke function
Derived class print function
So polymorphic behaviour works even when a virtual function is called inside a non-virtual function. The output can be guessed from the fact that the function to be called is decided at run-time using the vptr and vtable.

==========================================================================================

FAQ:
1. What is a pure virtual function?

Ans. A pure virtual function (or abstract function) in C++ is a virtual function for which we don’t have implementation, we only declare it. A pure virtual function is declared by assigning 0 in declaration. See the following example.


// An abstract class 
class Test { 
    // Data members of class 
public: 
    // Pure Virtual Function 
    virtual void show() = 0; 
  
    /* Other members */
}; 
2. What is abstract class?
Ans. A class which contains atleast one pure virtual function, is known as abstract class. see the following example


// An abstract class 
class Test { 
    // Data members of class 
public: 
    // Pure Virtual Function 
    virtual void show() = 0; 
  
    /* Other members */
}; 
in above example, Test is an abstract class because it has a pure virtual function.
========================================================================================

Types of Classes:

Concrete class:
A class in which all the functionalities of an object are defined is called as concrete class.
 
Abstract class:
A class which contains generic/common features that multiple derived class can share.

pure abstract class:
A class in which all the member functions are pure virtual functions is called as pure abstract class. It is just an interface and cannot be instantiated.

Polymorphic class:
A class that contains at least one virtual function is called as polymorphic class.
=================================================================================

How virtual function works?
class A
{
	//without virtual function
};
class B
{
	//with virtual function
};
int main()
{
	A a;
	B b;
	cout<<"size of object a is "<<sizeof(a);
	cout<<"size of object a is "<<sizeof(b);
}
class B contains a virtual function whereas class A doesnot contain any virtual function. If the size of the objects of both the classes A and B is compared, then size of object b is 4 bytes more than the size of object a.The reason is, for every class which contains at least one virtual function, the compiler implicitly adds a virtual pointer.


=======================================================================================
If a class contains a virtual function then the compiler itself does two things.

1)If an object of that class is created then a virtual pointer (VPTR) is inserted as a data member of the class to point to the VTABLE of that class. For each new object created, a new virtual pointer is inserted as a data member of that class.
2)Irrespective of whether the object is created or not, the class contains as a member a static array of function pointers called VTABLE. Cells of this table store the address of each virtual function contained in that class.

Virtual Functions in C++

The most common use of runtime binding  is with base class pointers or references calling derived class functions. This is called runtime polymorphism and is implemented in C++ using virtual functions.
A virtual function is a member function that is declared within a base class with the virtual keyword and is re-defined (Overridden) by a derived class. When a class contains a virtual function, it can be overridden in its derived class and tells the compiler to perform dynamic linkage (or late binding) on the function. Now, the virtual functions are implemented in C++ by using vTable and vPtr.

What is VTable ?
==>VTable is a class specific. It is a static member of the class since all the objects of a class refer to the same virtual table. It contains the addresses of the respective virtual functions of that class. VTable  is a constant array of function pointers which contains pointers to all virtual functions of the class. All the object of a class refer to its own virtual table.
==>If in the derived class,a function that is declared as virtual in the base class is not overridden, then the compiler uses the address of the base class version in the derived class virtual table.


What is Vptr (Virtual Pointer)?

==>Every object of a polymorphic class has a hidden pointer called virtual pointer(vptr). it is a pointer to VTable and is automatically initialized to the starting address of the VTable in the constructor.
==>The virtual pointer or _vptr is a hidden pointer that is added by the compiler as a member of the class to point to the VTable of that class. Every object of a class containing virtual functions, a vptr is added to point to the vTable of that class. It’s important to note that vptr is created only if a class has or inherits a virtual function.
==>The setting up of the VTable for each polymorphic class, initializing the Vptr and inserting the codefor the function call happens automatically, the programmer doesnot have to worry about it.

consider Employee and Salesperson are polymorphic class.

==>when a class containing a virtual function is created or a class is derived from a class that contains virtual functions,compiler creates a unique VTable for that class.In VTable ,the compiler stores the addresses of all virtual functions.Each object contains vptr that points to VTable of that class.
==>The compiler places Vptr as a data member in the class created per object.Vptr is initialized to the starting address of the appropriate VTable.when salesperson object is created,it contains VPtr as one ofits data members which points to the appropriate VTable.

int main()
{
Employee * ptr;
ptr=new Salesperson();
ptr->display();
}

The compiler picks up the Vptr of the object pointed by ptr.Thus instead of calling Employee::display() the compiler generates the code that says the function at Vptr should be called.The fectching of Vptr and the determination of the actual function address occur at runtime,thus late binding is achieved.

// C++ program to show the working of vtable and vptr 
#include <iostream> 
using namespace std; 
  
// base class 
class Base { 
public: 
    virtual void function1() 
    { 
        cout << "Base function1()" << endl; 
    } 
    virtual void function2() 
    { 
        cout << "Base function2()" << endl; 
    } 
    virtual void function3() 
    { 
        cout << "Base function3()" << endl; 
    } 
}; 
  
// class derived from Base 
class Derived1 : public Base { 
public: 
    // overriding function1() 
    void function1() 
    { 
        cout << "Derived1 function1()" << endl; 
    } 
    // not overriding function2() and function3() 
}; 
  
// class derived from Derived1 
class Derived2 : public Derived1 { 
public: 
    // again overriding function2() 
    void function2() 
    { 
        cout << "Derived2 function2()" << endl; 
    } 
    // not overriding function1() and function3() 
}; 
  
// driver code 
int main() 
{ 
    // defining base class pointers 
    Base* ptr1 = new Base(); 
    Base* ptr2 = new Derived1(); 
    Base* ptr3 = new Derived2(); 
  
    // calling all functions 
    ptr1->function1(); 
    ptr1->function2(); 
    ptr1->function3(); 
    ptr2->function1(); 
    ptr2->function2(); 
    ptr2->function3(); 
    ptr3->function1(); 
    ptr3->function2(); 
    ptr3->function3(); 
  
    // deleting objects 
    delete ptr1; 
    delete ptr2; 
    delete ptr3; 
  
    return 0; 
}

Output
Base function1()
Base function2()
Base function3()
Derived1 function1()
Base function2()
Base function3()
Derived1 function1()
Derived2 function2()
Base function3()



1)A class contains atleast one virtual function,that class is calles as polymorphic class
2)compiler implicitely add a virtual pointer for every polymorphic class i.e vptr
3)vptr is created per object
4)vtable is called as static array of function pointer.
5)vtable is created per class
6)vtable will store the address of all the virtual functions
7)vptr will point to the starting address of the table.

===========================================================================================
Multiple Inheritance in C++:

Multiple Inheritance is a feature of C++ where a class can inherit from more than one classes.  The constructors of inherited classes are called in the same order in which they are inherited.
==>The list of base classes memtioned in the derived class declaration must be seperated by commas and each of the base classes should use its own specifier . If the class specifier is not specified,default is private.
==>The order in which base class constructors are invoked is the same as the  order in which they appear in the derived class constructor's member initialization list.
Syntax:

class A
{ 
... .. ... 
};
class B
{
... .. ...
};
class C: public A,public B
{
... ... ...
};

#include<iostream>
using namespace std;
 
class A
{
public:
  A()  { cout << "A's constructor called" << endl; }
};
 
class B
{
public:
  B()  { cout << "B's constructor called" << endl; }
};
 
class C: public B, public A  // Note the order
{
public:
  C()  { cout << "C's constructor called" << endl; }
};
 
int main()
{
    C c;
    return 0;
}
Output:

B's constructor called
A's constructor called
C's constructor called
The destructors are called in reverse order of constructors.

Ambiguity Problem in Multiple Inheritance
In Multiple Inheritance, when a single class is derived from two or more base or parent classes. So, it might be possible that both the parent class have the same-named member functions, and it shows ambiguity when the child class object invokes one of the same-named member functions. Hence, we can say, the C++ compiler is confused in selecting the member function of a class for the execution of a program.
ex:
Base classes can contain a function with the same name,signature and returntype.
class A
{ 
... .. ... 
};
class C
{
... .. ...
};
class B: public A,public B
{
... ... ...
};
B bobj
bobj.func();

==>Here,the function call is ambiguous and doesnot compile,because it is not clear whether it refers to A::func() or C::func().This ambiguity can be resolved by any one of the following 2 ways.
1)Making the call explicit by resolving the function call with the classname i.e specifying either  bobj.A::func() or bobj.c::func()
2)overriding the func() in class B . then the statement bobj.func() will call func() of class B and the call will not be ambiguous.

#include <iostream>  
#include <conio.h>  
  
using namespace std;  
  
// create class A  
class A  
{  
    public:   
    void show()  
    {  
        cout << " It is the member function of class A " << endl;  
    }  
 };   
   
 // create class B  
 class B  
{  
    public:   
    void show()  
    {  
        cout << " It is the member function of class B " << endl;  
    }  
 };  
   
   
 // create a child class to inherit the member function of class A and class B  
 class child: public A, public B  
 {  
    public:  
        void disp()  
        {  
            cout << " It is the member function of the child class " << endl;  
         }  
 };  
   
 int main ()  
 {  
    // create an object of the child class to access the member function  
    child ch;  
    ch.show(); // It causes ambiguity   
ch.disp();  
    return 0;  
 }  
==================================================================



Diamond Inheritance:
In diamond inheritance,one child has two parents and both the parents share a common parent. When in a hierarchy, a class is derived from two classes and both the classes are derived from a common base class,it is termed as diamond inheritance.

The diamond problem The diamond problem occurs when two superclasses of a class have a common base class. For example, in the following diagram, the TA class gets two copies of all attributes of Person class, this causes ambiguities.

#include<iostream>
using namespace std;
class Person {
   // Data members of person 
public:
    Person(int x)  { cout << "Person::Person(int ) called" << endl;   }
};
 
class Faculty : public Person {
   // data members of Faculty
public:
    Faculty(int x):Person(x)   {
       cout<<"Faculty::Faculty(int ) called"<< endl;
    }
};
 
class Student : public Person {
   // data members of Student
public:
    Student(int x):Person(x) {
        cout<<"Student::Student(int ) called"<< endl;
    }
};
 
class TA : public Faculty, public Student  {
public:
    TA(int x):Student(x), Faculty(x)   {
        cout<<"TA::TA(int ) called"<< endl;
    }
};
 
int main()  {
    TA ta1(30);
}
Person::Person(int ) called
Faculty::Faculty(int ) called
Person::Person(int ) called
Student::Student(int ) called
TA::TA(int ) called
In the above program, constructor of ‘Person’ is called two times. Destructor of ‘Person’ will also be called two times when object ‘ta1’ is destructed. So object ‘ta1’ has two copies of all members of ‘Person’, this causes ambiguities. The solution to this problem is ‘virtual’ keyword. We make the classes ‘Faculty’ and ‘Student’ as virtual base classes to avoid two copies of ‘Person’ in ‘TA’ class.
==========================================================================================
#include<iostream>
using namespace std;
class Person {
public:
    Person(int x)  { cout << "Person::Person(int ) called" << endl;   }
    Person()     { cout << "Person::Person() called" << endl;   }
};
 
class Faculty : virtual public Person {
public:
    Faculty(int x):Person(x)   {
       cout<<"Faculty::Faculty(int ) called"<< endl;
    }
};
 
class Student : virtual public Person {
public:
    Student(int x):Person(x) {
        cout<<"Student::Student(int ) called"<< endl;
    }
};
 
class TA : public Faculty, public Student  {
public:
    TA(int x):Student(x), Faculty(x)   {
        cout<<"TA::TA(int ) called"<< endl;
    }
};
 
int main()  {
    TA ta1(30);
}
Output:

Person::Person() called
Faculty::Faculty(int ) called
Student::Student(int ) called
TA::TA(int ) called
In the above program, constructor of ‘Person’ is called once. One important thing to note in the above output is, the default constructor of ‘Person’ is called.When we use ‘virtual’ keyword, the default constructor of grandparent class is called by default even if the parent classes explicitly call parameterized constructor.
=======================================================================================
How to call the parameterized constructor of the ‘Person’ class?

The constructor has to be called in ‘TA’ class.

For example, see the following program. 

   
#include<iostream>
using namespace std;
class Person {
public:
    Person(int x)  { cout << "Person::Person(int ) called" << endl;   }
    Person()     { cout << "Person::Person() called" << endl;   }
};
 
class Faculty : virtual public Person {
public:
    Faculty(int x):Person(x)   {
       cout<<"Faculty::Faculty(int ) called"<< endl;
    }
};
 
class Student : virtual public Person {
public:
    Student(int x):Person(x) {
        cout<<"Student::Student(int ) called"<< endl;
    }
};
 
class TA : public Faculty, public Student  {
public:
    TA(int x):Student(x), Faculty(x), Person(x)   {
        cout<<"TA::TA(int ) called"<< endl;
    }
};
 
int main()  {
    TA ta1(30);
}
Output:

Person::Person(int ) called
Faculty::Faculty(int ) called
Student::Student(int ) called
TA::TA(int ) called
In general, it is not allowed to call the grandparent’s constructor directly, it has to be called through parent class. It is allowed only when ‘virtual’ keyword is used.
=====================================================================================
FAQ:
class S: public A1, virtual A2
{
….
};                                                                                            

Here,
A2(): virtual base constructor
A1(): base constructor
S(): derived constructor

Example 1: Below is the C++ program to show the concept of Constructor in Multiple Inheritance.


// C++ program to implement
// constructor in multiple 
// inheritance
#include<iostream>
using namespace std;
class A1
{
  public:
  A1()
  {
    cout << "Constructor of the base class A1 \n";
  }
 
};
 
class A2
{
  public:
  A2()
  {
    cout << "Constructor of the base class A2 \n";
  }
 
};
 
class S: public A1, virtual A2
{
  public:
  S(): A1(), A2()
  {
    cout << "Constructor of the derived class S \n";
  }
};
 
// Driver code
int main()
{
  S obj;
  return 0;
}
Output
Constructor of the base class A2 
Constructor of the base class A1 
Constructor of the derived class S 
====================================================================

FAQ ON MULTIPLE INHERITANCE:

1)
#include<iostream> 
   
using namespace std; 
class Base1 { 
 public: 
     Base1() 
     { cout << " Base1's constructor called" << endl;  } 
}; 
   
class Base2 { 
 public: 
     Base2() 
     { cout << "Base2's constructor called" << endl;  } 
}; 
   
class Derived: public Base1, public Base2 { 
   public: 
     Derived() 
     {  cout << "Derived's constructor called" << endl;  } 
}; 
   
int main() 
{ 
   Derived d; 
   return 0; 
} 
(A) Compiler Dependent


(B) Base1′s constructor called
Base2′s constructor called
Derived’s constructor called


(C) Base2′s constructor called
Base1′s constructor called
Derived’s constructor called


(D) Compiler Error


Answer: (B)

Explanation: When a class inherits from multiple classes, constructors of base classes are called in the same order as they are specified in inheritance.
===================================================================================================
2)
#include <iostream>   
using namespace std; 
  
class Base1 { 
 public: 
     ~Base1()  { cout << " Base1's destructor" << endl; } 
}; 
    
class Base2 { 
 public: 
     ~Base2()  { cout << " Base2's destructor" << endl; } 
}; 
    
class Derived: public Base1, public Base2 { 
   public: 
     ~Derived()  { cout << " Derived's destructor" << endl; } 
}; 
    
int main() 
{ 
   Derived d; 
   return 0; 
} 
(A)
Base1's destructor
Base2's destructor
Derived's destructor
(B)
Derived's destructor
Base2's destructor
Base1's destructor
(C)
Derived's destructor
(D) Compiler Dependent

Answer: (B)

Explanation: Destructors are always called in reverse order of constructors.
==================================================================================
3)


#include<iostream> 
   
using namespace std; 
class P { 
public: 
   void print()  { cout <<" Inside P"; } 
}; 
   
class Q : public P { 
public: 
   void print() { cout <<" Inside Q"; } 
}; 
   
class R: public Q { }; 
   
int main(void) 
{ 
  R r;  
  r.print(); 
  return 0; 
} 
(A) Inside P
(B) Inside Q
(C) Compiler Error: Ambiguous call to print()


Answer: (B)

Explanation: The print function is not present in class R. So it is looked up in the inheritance hierarchy. print() is present in both classes P and Q, which of them should be called? The idea is, if there is multilevel inheritance, then function is linearly searched up in the inheritance hierarchy until a matching function is found.
======================================================================================




Virtual base class in C++

Virtual base classes are used in virtual inheritance in a way of preventing multiple “instances” of a given class appearing in an inheritance hierarchy when using multiple inheritances. 

Need for Virtual Base Classes: Consider the situation where we have one class A . This class A is inherited by two other classes B and C. Both these class are inherited into another in a new class D

data members/function of class A are inherited twice to class D. One through class B and second through class C. When any data / function member of class A is accessed by an object of class D, ambiguity arises as to which data/function member would be called? One inherited through B or the other inherited through C. This confuses compiler and it displays error. 

Example: To show the need of Virtual Base Class in C++ 
#include <iostream> 
using namespace std; 
  
class A { 
public: 
    void show() 
    { 
        cout << "Hello form A \n"; 
    } 
}; 
  
class B : public A { 
}; 
  
class C : public A { 
}; 
  
class D : public B, public C { 
}; 
  
int main() 
{ 
    D object; 
    object.show(); 
} 
Compile Errors:

prog.cpp: In function 'int main()':
prog.cpp:29:9: error: request for member 'show' is ambiguous
  object.show();
         ^
prog.cpp:8:8: note: candidates are: void A::show()
   void show()
        ^
prog.cpp:8:8: note:                 void A::show()
How to resolve this issue? 
To resolve this ambiguity when class A is inherited in both class B and class C, it is declared as virtual base class by placing a keyword virtual as : 

Syntax for Virtual Base Classes:

Syntax 1:
class B : virtual public A 
{
};
Syntax 2:
class C : public virtual A
{
};
Note: 
virtual can be written before or after the public. Now only one copy of data/function member will be copied to class C and class B and class A becomes the virtual base class. Virtual base classes offer a way to save space and avoid ambiguities in class hierarchies that use multiple inheritances. When a base class is specified as a virtual base, it can act as an indirect base more than once without duplication of its data members. A single copy of its data members is shared by all the base classes that use virtual base. 




#include <iostream> 
using namespace std; 
  
class A { 
public: 
    int a; 
    A() // constructor 
    { 
        a = 10; 
    } 
}; 
  
class B : public virtual A { 
}; 
  
class C : public virtual A { 
}; 
  
class D : public B, public C { 
}; 
  
int main() 
{ 
    D object; // object creation of class d 
    cout << "a = " << object.a << endl; 
  
    return 0; 
} 
Output
a = 10
Explanation :
To solve this ambiguity we will make class “A” as a virtual base class. To make a virtual base class “virtual” keyword is used.

When one class is made virtual then only one copy of its data member and member function is passed to the classes inheriting it. So in our example when we will make class “A” a virtual class then only one copy of the data member and member function will be passed to the classes “B” and “C” which will be shared between all classes. This will help to solve the ambiguity.

When a class is specified as a virtual base class, it prevents duplication of its data members. Only one copy of its data members is shared by all the base classes that use the virtual base class.
If a virtual base class is not used, all the derived classes will get duplicated data members. In this case, the compiler cannot decide which one to execute.

NOTE:
In this case, we are using a virtual base class in C++, so only one copy of data from Class A was inherited to Class D; hence, the compiler will be able to print the output.
When we mention the base class as virtual, we avoid the situation of duplication and let the derived classes get only one copy of the data.

There are a few details that one needs to remember.

1)Virtual base classes are always created before non-virtual base classes. This ensures all bases are created before their derived classes.
2)Note that classes B and C still have calls to class A, but they are simply ignored when creating an object of class D. If we are creating an object of class B or C, then the constructor of A will be called.
3)If a class inherits one or more classes with virtual parents, the most derived class is responsible for constructing the virtual base class. Here, class D is responsible for creating class A object.
========================================================================================

book:
problem 1:
If the base class contain a function with same name then while calling this function in the derived class or through an object of derived class, the compiler flashes an error of ambiguous call.

problem 2:
data duplication occurs when the derived class has multiple copies of the same base class.

==>To avoid 2 major problems in case of diamond inheritance,c++ introduces a concept of a virtual base class. A virtual base class is a class that is virtually present in its derived classes(i.e in the form of pointer). 
==>A base class is made virtual by placing the keyword virtual before its name in the derived class declaration.
==Virtual base classes offer a way to save spacce and aoid ambiguities in class hierarchies that use diamond inheritance.
==>When a base class is specified as virtual,it can act as an indirect base class more than once without duplicating its data members.A single copy of its data members is shared by all the base classes that use it as virtual base.

Employee:  id
Manager:petrolallow,foodallow,virtual base pointer
Salesperson:sales,comm,virtual base pointer
Salesmanager:petrolallow,foodallow,virtual base pointer + sales,comm,virtual base pointer

class Salesperson:virtual public Employee
{}

class Manager:virtual public Employee
{}

Class Employee becomes a virtual base class.The data members of the virtual base class are not directly present in the derived class. Instead, the derived class Salesperson and Manager acquire a pointer each. This pointer is called virtual base pointer.It causes the size of their objects to increase by 4 bytes each. This virtual base pointer points to common data members of the virtual base class.

Constructors in multiple inheritance:

If the virtual base class has constructors, then the most derived class constructor is responsible for initializing the virtual base class.
==>Employee is the virtual base class.The most derived class constructor is responsible for invoking the Employee constructor.
ex:SalesManager constructor must be as follow:
SalesManager::SalesManager(--):Employee(--),Salesperson(-),Manager(-)
{
}

Now on instantiating an object sm1 of class Salesmanager
1)memory is alloacted for the salesmanager object
2)constructor of the class  salesmanager is invoked
3)constructor of the class  Employee is invoked and executed directly
4)constructor of the class that appears first when the  salesmanager class is derived(i.e salesperson) is invoked and executed.
5)constructor of the class that appears next  is invoked and executed
6)constructor of the class  salesmanager is executed.

==>As Employee class is made a virtual base class, the code that was written previously for accept(),where the compiler was giving error as ambiguous call for the statement Employee:accept() will work fine.
=====================================================================================
Inline Function

==>we can use several methods to optimize the code and enhance a program’s performance. For example, in the C language, the Macro function is used to reduce the program’s execution time. Since C++ is an extension of C, it also provides a function called the inline function, which can speed up a program by reducing the execution time. 
==>C++ provides inline functions to reduce the function call overhead. An inline function is a function that is expanded in line when it is called. When the inline function is called whole code of the inline function gets inserted or substituted at the point of the inline function call. This substitution is performed by the C++ compiler at compile time. An inline function may increase efficiency if it is small.

==>Syntax:

inline return-type function-name(parameters)
{
    // function code
}  

==>Remember, inlining is only a request to the compiler, not a command. The compiler can ignore the request for inlining. 

==>The compiler may not perform inlining in such circumstances as: 
If a function contains a loop. (for, while and do-while) 
If a function is recursive. 
If a function return type is other than void, and the return statement doesn’t exist in a function body. 
If a function contains a switch or goto statement. 

Why Inline Functions are Used?
1)When the program executes the function call instruction the CPU stores the memory address of the instruction following the function call, copies the arguments of the function on the stack, and finally transfers control to the specified function. The CPU then executes the function code, stores the function return value in a predefined memory location/register, and returns control to the calling function. This can become overhead if the execution time of the function is less than the switching time from the caller function to called function (callee). 

For functions that are large and/or perform complex tasks, the overhead of the function call is usually insignificant compared to the amount of time the function takes to run. However, for small, commonly-used functions, the time needed to make the function call is often a lot more than the time needed to actually execute the function’s code. This overhead occurs for small functions because the execution time of a small function is less than the switching time.

==>When a function is invoked, it expands in line and is known as an inline function. When an inline function is invoked, its entire body of code is added or replaced at the inline function call location. At compile time, the C++ compiler makes this substitution.

2)The main use of the inline function in C++ is to save memory space. Whenever the function is called, then it takes a lot of time to execute the tasks, such as moving to the calling function. If the length of the function is small, then the substantial amount of execution time is spent in such overheads, and sometimes time taken required for moving to the calling function will be greater than the time taken required to execute that function.

The solution to this problem is to use macro definitions known as macros. The preprocessor macros are widely used in C, but the major drawback with the macros is that these are not normal functions which means the error checking process will not be done during the compilation.

C++ has provided one solution to this problem. In the case of function calling, the time for calling such small functions is huge, so to overcome such a problem, a new concept was introduced known as an inline function. When the function is encountered inside the main() method, it is expanded with its definition thus saving time.

Note:
Following are some key points that you need to keep in mind while dealing with inline functions:
Inline functions that are small have higher efficiency and better results than the lengthier inline functions. So, try to keep your inline functions small in length.
Although these functions increase the efficiency of the program and improve its execution, you should not convert all the functions into inline functions. If you convert larger functions to inline, it may lead to code bloat and reduce the functioning quality of the program.
Always try to define large functions outside the class, since functions defined inside a class are automatically defined as inline and this will affect the program negatively. You can use scope resolution (::) for this purpose.



Inline functions Advantages: 
Function call overhead doesn’t occur. 
It also saves the overhead of push/pop variables on the stack when a function is called. 
It also saves the overhead of a return call from a function. 
enhance the execution time and speed of your program.
The compilation speed of the program gets increased since the inline functions prevent function call overhead. 


Inline function Disadvantages: 
1)If you use too many inline functions then the size of the binary executable file will be large, because of the duplication of the same code. 
2)The inline function may increase compile time overhead if someone changes the code inside the inline function then all the calling location has to be recompiled because the compiler would be required to replace all the code once again to reflect the changes, otherwise it will continue with old functionality. 

#include <iostream>
using namespace std;
inline int cube(int s) { return s * s * s; }
int main()
{
    cout << "The cube of 3 is: " << cube(3) << "\n";
    return 0;
}

Output
The cube of 3 is: 27

========================================
==>If you need to explicitly declare an inline function in the class then just declare the function inside the class and define it outside the class using the inline keyword. 


For Example: 

class S
{
public:
    int square(int s); // declare the function
};

inline int S::square(int s) // use inline prefix
{
}

=================================================================
// C++ Program to demonstrate inline functions and classes
#include <iostream>
 
using namespace std;
 
class operation {
    int a, b, add, sub, mul;
    float div;
 
public:
    void get();
    void sum();
    void difference();
    void product();
    void division();
};
inline void operation ::get()
{
    cout << "Enter first value:";
    cin >> a;
    cout << "Enter second value:";
    cin >> b;
}
 
inline void operation ::sum()
{
    add = a + b;
    cout << "Addition of two numbers: " << a + b << "\n";
}
 
inline void operation ::difference()
{
    sub = a - b;
    cout << "Difference of two numbers: " << a - b << "\n";
}
 
inline void operation ::product()
{
    mul = a * b;
    cout << "Product of two numbers: " << a * b << "\n";
}
 
inline void operation ::division()
{
    div = a / b;
    cout << "Division of two numbers: " << a / b << "\n";
}
 
int main()
{
    cout << "Program using inline function\n";
    operation s;
    s.get();
    s.sum();
    s.difference();
    s.product();
    s.division();
    return 0;
}
Output:

Enter first value: 45
Enter second value: 15
Addition of two numbers: 60
Difference of two numbers: 30
Product of two numbers: 675
Division of two numbers: 3 
=======================================================================
What is wrong with the macro? 
There are some problems with the use of macros in C++. 
Macro cannot access private members of the class.
the major drawback with the macros is that these are not normal functions which means the error checking process will not be done during the compilation.
One other thing is that the macros are managed by the preprocessor and inline functions are managed by the C++ compiler. 

===========================================================================



=============================================================================


FAQ

Difference between Inline and Macro in C++

Macro : It is also called preprocessors directive. The macros are defined by the #define keyword. Before the program compilation, the preprocessor examines the program whenever the preprocessor detects the macros then preprocessor replaces the macro by the macro definition. Syntax of Macro:
#define MACRO_NAME Macro_definition 
Example of Macro:
 
#include <iostream> 
using namespace std; 
  
// macro with parameter 
#define MAXIMUM(a, b) (a > b) ? a : b 
  
// Main function for the program 
int main() 
{ 
    cout << "Max (100, 1000):"; 
    int k = MAXIMUM(100, 1000); 
    cout << k << endl; 
  
    cout << "Max (20, 0):"; 
    int k1 = MAXIMUM(20, 0); 
    cout << k1; 
  
    return 0; 
} 
Output:
Max (100, 1000):1000
Max (20, 0):20 

	Inline	Macro
1.	An inline function is defined by the inline keyword.	Whereas the macros are defined by the #define keyword.
2.	Through inline function, the class data members can be accessed.	Whereas macro can’t access the class data members.
3.	In the case of inline function, the program can be easily debugged.	Whereas in the case of macros, the program can’t be easily debugged.
4.	In the case of inline, the arguments are evaluated only once.	Whereas in the case of macro, the arguments are evaluated every time whenever macro is used in the program.
5.	In C++, inline may be defined either inside the class or outside the class.	Whereas the macro is all the time defined at the beginning of the program.
Inline functions are expanded by the compiler.Macros are expanded by the preprocessor.

==========================================================================================
Inline Function vrs Normal Function  

1	It is expanded inline when it is invoked. 	It is a function that provides modularity to the program.  
2.	It is basically a function that is used when functions are small and called very often.  	It is basically a group of statements that performs a particular task.  It is used when functions are big.
3.	It requires ‘inline‘ keyword in its declaration.  	It does not require any keyword in its declaration.  
4.	It generally executes much faster as compared to normal functions.  	It generally executes slower than inline function for small size function.  
5.	The compiler always places a copy of the code of that function at each point where the function is called at compile time. 	It does not provide such a type of functionality.  
6.	Too many inline functions affect file size after compilation as it duplicates the same code.  	Too many normal functions do not affect file size after compilation. 
================================================================
Enumeration in c++

What Is C++ Enum?

==>Enumeration (or enum) is a user defined data type in C. It is mainly used to assign names to integral constants, the names make a program easy to read and maintain.

==>Enum, which is also known as enumeration, is a user-defined data type that enables you to create a new data type that has a fixed range of possible values, and the variable can select one value from the set of values. For example, suppose you are the owner of an ice cream shop, and you sell a limited range of ice cream flavors. So you want the customers to select only from that collection of ice creams in your shop. This becomes an enumeration with ice cream as the name of enumeration and different flavors of ice creams as its elements.

==>Enumeration (Enumerated type) is a user-defined data type that can be assigned some limited values. These values are defined by the programmer at the time of declaring the enumerated type.

Syntax:

enum enumerated-type-name
{
    value1, value2, value3…..valueN
};

enum Iceccream
{
	vanilla,stawberry,mango
};
Each of these elements has values starting from 0, like vanilla is 0, stawberry is 1, etc. The default values mentioned can be altered during the declaration of the enum in C++.

For Example: If a gender variable is created with the value male or female. If any other value is assigned other than male or female then it is not appropriate. In this situation, one can declare the enumerated type in which only male and female values are assigned.
============================================================================
Declaration
To declare an enum variable, write the name of the enumeration along with the enum variable.

enum Iceccream
{
	vanilla,stawberry,mango
};
int main()
{
	Icecream i;
}
Here i is the enum variable.
===========================================================
Example:

//first_enum is the enumerated-type-name
enum first_enum{value1=1, value2=10, value3};

In this case, 
first_enum e;
e=value3;
cout<<e;

Output:
11
=========================================================
// C++ Program to Demonstrate the Functioning of Enumerators 
// with an example of Gender 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    // Defining enum Gender 
    enum Gender { Male, Female }; 
  
    // Creating Gender type variable 
    Gender gender = Male; 
  
    switch (gender) { 
    case Male: 
        cout << "Gender is Male"; 
        break; 
    case Female: 
        cout << "Gender is Female"; 
        break; 
    default: 
        cout << "Value can be Male or Female"; 
    } 
    return 0; 
}// C++ Program to Demonstrate the Functioning of Enumerators 
// with an example of Gender 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    // Defining enum Gender 
    enum Gender { Male, Female }; 
  
    // Creating Gender type variable 
    Gender gender = Male; 
  
    switch (gender) { 
    case Male: 
        cout << "Gender is Male"; 
        break; 
    case Female: 
        cout << "Gender is Female"; 
        break; 
    default: 
        cout << "Value can be Male or Female"; 
    } 
    return 0; 
}
=====================================================================
// C++ Program to Demonstrate the Functioning of Enumerators 
// with an Example of Year 
#include <bits/stdc++.h> 
using namespace std; 
  
// Defining enum Year 
enum year { 
    Jan, 
    Feb, 
    Mar, 
    Apr, 
    May, 
    Jun, 
    Jul, 
    Aug, 
    Sep, 
    Oct, 
    Nov, 
    Dec 
}; 
  
// Driver Code 
int main() 
{ 
    int i; 
  
    // Traversing the year enum 
    for (i = Jan; i <= Dec; i++) 
        cout << i << " "; 
  
    return 0; 
}

Output: 
0 1 2 3 4 5 6 7 8 9 10 11
==============================================================
Points to remember for C++ Enum
enum improves type safety
enum can be easily used in switch
enum can be traversed
The C++ enum constants are  final implicitly.

If we assign a float value to a character value, then the compiler generates an error. In the same way, if we try to assign any other value to the enumerated data types, the compiler generates an error.


#include <iostream>  
using namespace std;  
enum week { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday };  
int main()  
{  
    week day;  
    day = Friday;  
    cout << "Day: " << day+1<<endl;  
    return 0;  
} 
=======================================
   #include <iostream>
using namespace std;

enum suit {
    club = 0,
    diamonds = 10,
    hearts = 20,
    spades = 3
} card;

int main() 
{
    card = club;
    cout << "Size of enum variable " << sizeof(card) << " bytes.";   
    return 0;
}
Output

Size of enum variable 4 bytes.
It's because the size of an integer is 4 bytes.; 

Why enums are used in C++ programming?

Enums are used to give names to constants, which makes the code easier to read and maintain.
Use enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc.

1)Enums or enumerations are generally used when you expect the variable to select one value from the possible set of values
2)Enums are strongly typed, which means that the compiler will catch any errors at compile time rather than at runtime. ...
3)readable: Enums provide a more readable way to define a fixed set of values. ...
4)extensible: Enums can be extended to add new values.
5)Enums are used when we know all possible values at compile time, such as choices on a menu, rounding modes
=====================================================================
More points on Enum

Multiple enum names or elements can have the same value. Here’s an example of two enum elements having a similar value.

Example:
#include <stdio.h>

enum Cars{Jeep = 1, BMW = 0, Mercedes_Benz = 0};

int main(){

    printf("%d, %d, %d", Jeep, BMW, Mercedes_Benz);

    return 0;

}

Output:
==============================
All the enum elements or constants should have a unique scope. It means that an element cannot be a part of two different enums in the same program as it will fail during compilation. Here’s an example:

Example:
#include <stdio.h>

enum Cars{Mahindra, Jeep, BMW};

enum Luxury_Cars{BMW, Ferrari, Mercedes_Benz};

int main(){

    return 0;

}
===========================================================
Two enumerations cannot share the same names: 
 

CPP
 
#include <bits/stdc++.h>
using namespace std;
 
int main()
{
    // Defining enum1 Gender
    enum Gender { Male,
                  Female };
 
    // Defining enum2 Gender2 with same values
    // This will throw error
    enum Gender2 { Male,
                   Female };
 
    // Creating Gender type variable
    Gender gender = Male;
    Gender2 gender2 = Female;
 
    cout << gender << endl
         << gender2;
 
    return 0;
}

Compilation Error: 
 

prog.cpp:13:20: error: redeclaration of 'Male'
     enum Gender2 { Male,
                    ^
prog.cpp:8:19: note: previous declaration 'main()::Gender Male'
     enum Gender { Male,
                   ^
prog.cpp:14:20: error: redeclaration of 'Female'
                    Female };
                    ^
prog.cpp:9:19: note: previous declaration 'main()::Gender Female'
                   Female };
                   ^
prog.cpp:18:23: error: cannot convert 'main()::Gender' 
to 'main()::Gender2' in initialization
     Gender2 gender2 = Female;
                       ^

 

No variable can have a name which is already in some enumeration:
 

CPP
 
#include <bits/stdc++.h>
using namespace std;
 
int main()
{
    // Defining enum1 Gender
    enum Gender { Male,
                  Female };
 
    // Creating Gender type variable
    Gender gender = Male;
 
    // creating a variable Male
    // this will throw error
    int Male = 10;
 
    cout << gender << endl;
 
    return 0;
}

Compilation Error: 
 

prog.cpp: In function 'int main()':
prog.cpp:16:9: error: 'int Male' redeclared as different kind of symbol
     int Male = 10;
         ^
prog.cpp:8:19: note: previous declaration 'main()::Gender Male'
     enum Gender { Male,
                   ^
==========================================================
Why use an enum in a program?
One can utilise the enums in a program when they want the variables in the program to have just the set of values. For instance, let us consider the creation of a direction variable. Now, there are a total of four directions (N, S, W, E). Thus, a total of four values are possible with the direction variable. But here, the variable would be able to hold just a single value at any given time. Now, if a user provides any different value to the variable here, then we would get a compilation error.

We can also use the enum in the case of switch case statements. In this statement, we pass all the enum variables within the switch parenthesis. This step would basically ensure that we have to define the value of the case block in an enum.

Now, we will see how one can make use of an enum within a switch case statement. Let us take a look:

#include <stdio.h>

enum vegetables{broccoli=1, spinach, carrot, eggplant, celery, pumpkin, shallot};

int main()

{

enum vegetables v;

v=broccoli;

switch(v)

{

case broccoli:

printf(“I will eat broccoli”);

break;

case spinach:

printf(“I will eat spinach”);

break;

case carrot:

printf(“I will eat carrot”);

break;

case eggplant:

printf(“I will eat eggplant”);

break;

case celery:

printf(“I will eat celery”);

break;

case pumpkin:

printf(“I will eat pumpkin”);

break;

case shallot:

printf(“I will eat shallot”);

break;

}

return 0;

}
===================================================================
Friend Class and Function in C++

==>
Data hiding is a fundamental concept of object-oriented programming. It restricts the access of private members from outside of the class.
Similarly, protected members can only be accessed by derived classes and are inaccessible from outside. For example,
However, there is a feature in C++ called friend functions that break this rule and allow us to access member functions from outside the class.

A friend class can access private and protected members of other classes in which it is declared as a friend. 
It is sometimes useful to allow a particular class to access private and protected members of other classes. 

We can declare a friend class in C++ by using the friend keyword.

class Demo //Base class
{
	//Demo1 is a friend class of Demo
	friend class Demo1;
}
class Demo1 // friend class
{
//statements;
}

Syntax:
friend class class_name;    // declared in the base class

========================================================


// C++ Program to demonstrate the functioning of a friend class
#include <iostream>
using namespace std;
 class Demo {
private:
    int private_variable;
 protected:
    int protected_variable;
 
public:
    Demo()
    {
        private_variable = 10;
        protected_variable = 99;
    }
     // friend class declaration
    friend class F;
};
 // Here, class F is declared as a friend inside class Demo. Therefore,
// F is a friend of class Demo. Class F can access the private members of class Demo.
class F {
public:
    void display(Demo& t)
    {
        cout << "The value of Private Variable = "<< t.private_variable << endl;
        cout << "The value of Protected Variable = "<< t.protected_variable;
    }
};
int main()
{
    Demo g;
    F fri;
    fri.display(g);
    return 0;
}

Output
The value of Private Variable = 10
The value of Protected Variable = 99

Note: We can declare friend class or function anywhere in the base class body whether its private, protected or public block. It works all the same.
=====================================================================================
Friend Function




==>Like a friend class, a friend function can be granted special access to private and protected members of a class in C++. They are the non-member functions that can access and manipulate the private and protected members of the class for they are declared as friends.
If a function is defined as a friend function in C++, then the protected and private data of a class can be accessed using the function.

class Demo
{
//private members and functions
}
Friend function has the priviliges to access all private and protedcted members of the class.


A friend function can be:
A global function:
friend return_type function_name (arguments);    // for a global function
A member function of another class
friend return_type class_name::function_name (arguments);    // for a member function of another class
===================================================================
1. Global Function as Friend Function
We can declare any global function as a friend function. The following example demonstrates how to declare a global function as a friend function in C++:

Example:

   
// C++ program to create a global function as a friend
// function of some class
#include <iostream>
using namespace std;
 
class base {
private:
    int private_variable;
 
protected:
    int protected_variable;
 
public:
    base()
    {
        private_variable = 10;
        protected_variable = 99;
    }
     
      // friend function declaration
    friend void friendFunction(base& obj);
};
 
 
// friend function definition
void friendFunction(base& obj)
{
    cout << "Private Variable: " << obj.private_variable
         << endl;
    cout << "Protected Variable: " << obj.protected_variable;
}
 
// driver code
int main()
{
    base object1;
    friendFunction(object1);
 
    return 0;
}

Output
Private Variable: 10
Protected Variable: 99
In the above example, we have used a global function as a friend function. In the next example, we will use a member function of another class as a friend function.

==============================================================================================
2	Member Function of Another Class as Friend Function
We can also declare a member function of another class as a friend function in C++. The following example demonstrates how to use a member function of another class as a friend function in C++:

Example:

C++
   
// C++ program to create a member function of another class
// as a friend function
#include <iostream>
using namespace std;
 
class base; // forward definition needed
// another class in which function is declared
class anotherClass {
public:
    void memberFunction(base& obj);
};
 
// base class for which friend is declared
class base {
private:
    int private_variable;
 
protected:
    int protected_variable;
 
public:
    base()
    {
        private_variable = 10;
        protected_variable = 99;
    }
 
    // friend function declaration
    friend void anotherClass::memberFunction(base&);
};
 
// friend function definition
void anotherClass::memberFunction(base& obj)
{
    cout << "Private Variable: " << obj.private_variable
         << endl;
    cout << "Protected Variable: " << obj.protected_variable;
}
 
// driver code
int main()
{
    base object1;
    anotherClass object2;
    object2.memberFunction(object1);
 
    return 0;
}

Output
Private Variable: 10
Protected Variable: 99
Note: The order in which we define the friend function of another class is important and should be taken care of. We always have to define both the classes before the function definition. Thats why we have used out of class member function definition.
======================================================================

Features of Friend Functions
 A friend function is a special function in C++ that in spite of not being a member function of a class has the privilege to access the private and protected data of a class.
A friend function is a non-member function or ordinary function of a class, which is declared as a friend using the keyword “friend” inside the class. By declaring a function as a friend, all the access permissions are given to the function.
The keyword “friend” is placed only in the function declaration of the friend function and not in the function definition or call.
A friend function is called like an ordinary function. It cannot be called using the object name and dot operator. However, it may accept the object as an argument whose value it wants to access.
A friend function can be declared in any section of the class i.e. public or private or protected.
=======================================================
Advantages of Friend Functions
A friend function is able to access members without the need of inheriting the class.
The friend function acts as a bridge between two classes by accessing their private data.
It can be declared either in the public or private or protected part of the class.

Disadvantages of Friend Functions
Friend functions have access to private members of a class from outside the class which violates the law of data hiding.
Friend functions cannot do any run-time polymorphism 

Important Points About Friend Functions and Classes
Friends should be used only for limited purposes. Too many functions or external classes are declared as friends of a class with protected or private data access lessens the value of encapsulation of separate classes in object-oriented programming.
Friendship is not mutual. If class A is a friend of B, then B doesn’t become a friend of A automatically.
Friendship is not inherited. 



======================================================================================
Example :
#include <iostream>    
using namespace std;    
class Box    
{    
    private:    
        int length;    
    public:    
        Box(): length(0) { }    
        friend int printLength(Box); //friend function    
};    
int printLength(Box b)    
{    
   b.length += 10;    
    return b.length;    
}    
int main()    
{    
    Box b;    
    cout<<"Length of box: "<< printLength(b)<<endl;    
    return 0;    
}    
Output:

Length of box: 10  
=============================================================
Let's see a simple example when the function is friendly to two classes.

#include <iostream>  
using namespace std;  
class B;          // forward declarartion.  
class A  
{  
    int x;  
    public:  
    void setdata(int i)  
    {  
        x=i;  
    }  
    friend void min(A,B);         // friend function.  
};  
class B  
{  
    int y;  
    public:  
    void setdata(int i)  
    {  
        y=i;  
    }  
    friend void min(A,B);                    // friend function  
};  
void min(A a,B b)  
{  
    if(a.x<=b.y)  
    std::cout << a.x << std::endl;  
    else  
    std::cout << b.y << std::endl;  
}  
   int main()  
{  
   A a;  
   B b;  
   a.setdata(10);  
   b.setdata(20);  
   min(a,b);  
    return 0;  
 }  
Output:

10
In the above example, min() function is friendly to two classes, i.e., the min() function can access the private members of both the classes A and B.
=====================================================================
Example 2: Add Members of Two Different Classes
// Add members of two different classes using friend functions

#include <iostream>
using namespace std;

// forward declaration
class ClassB;

class ClassA {
    
    public:
        // constructor to initialize numA to 12
        ClassA() : numA(12) {}
        
    private:
        int numA;
        
         // friend function declaration
         friend int add(ClassA, ClassB);
};

class ClassB {

    public:
        // constructor to initialize numB to 1
        ClassB() : numB(1) {}
    
    private:
        int numB;
 
        // friend function declaration
        friend int add(ClassA, ClassB);
};

// access members of both classes
int add(ClassA objectA, ClassB objectB) {
    return (objectA.numA + objectB.numB);
}

int main() {
    ClassA objectA;
    ClassB objectB;
    cout << "Sum: " << add(objectA, objectB);
    return 0;
}
Run Code
Output

Sum: 13
In this program, ClassA and ClassB have declared add() as a friend function. Thus, this function can access private data of both classes.

One thing to notice here is the friend function inside ClassA is using the ClassB. However, we haven't defined ClassB at this point.

// inside classA 
friend int add(ClassA, ClassB);
For this to work, we need a forward declaration of ClassB in our program.

// forward declaration
class ClassB;
==================================================================================
C++ Program to swap two members using Friend Function

Approach: 
Create a class Swap, declare three variables in it, i.e., a, b, and temp and create a constructor for inputs. Declare a friend function in it. Define the friend function outside the class scope by taking arguments as call by reference to pass the copy of Swap Object. Perform the swap operation with Swap variables.

   
// C++ Program to swap two numbers using friend function
#include <iostream>
 using namespace std;
 class Swap {
 
    // Declare the variables of Swap Class
    int temp, a, b;
 
public:
 
    // Define the parameterized constructor, for inputs
    Swap(int a, int b)
    {
        this->a = a;
        this->b = b;
    }
 
    // Declare the friend function to swap, take arguments  as call by reference
    friend void swap1(Swap&);
};
 
// Define the swap function outside class scope
void swap1(Swap& s1)
{
    // Call by reference is used to passed object copy to
    // the function
    cout << "\nBefore Swapping: " << s1.a << " " << s1.b;
 
    // Swap operations with Swap Class variables
    s1.temp = s1.a;
    s1.a = s1.b;
    s1.b = s1.temp;
    cout << "\nAfter Swapping: " << s1.a << " " << s1.b;
}
 
// Driver Code
int main()
{
    // Declare and Initialize the Swap object
    Swap s(4, 6);
    swap1(s);
    return 0;
}

Output: 
Before Swapping: 4 6
After Swapping: 6 4


========================================================
Approach 2:
Approach: 
Create a class Swap, declare one variable in it, i.e., num and create a constructor for inputs. Declare a friend function in it. Define the friend function outside the class scope by taking arguments as call by reference to pass the copy of Swap Object. Perform the swap operation.

   
//C++ Program to swap data members of two objects of a class using friend function.
#include <iostream> 
   
using namespace std; 
   
class Swap { 
   
    // Declare the variable of Swap Class 
    int num;
   
public: 
   
    // Define the parameterized constructor, for input. 
    Swap(int num) 
    { 
        this->num = num; 
    } 
   
    // Declare the friend function to swap, take arguments  
    // as call by reference 
    friend void swap(Swap&, Swap&); 
}; 
   
// Define the swap function outside class scope 
void swap(Swap& s1, Swap& s2) 
{ 
    // declare a temporary variable.
    int temp;
    // Call by reference is used to passed object copy to 
    // the function 
    cout << "\nBefore Swapping: " << s1.num << " " << s2.num; 
   
    // Swap operations with objects of class Swap
    temp = s1.num; 
    s1.num = s2.num; 
    s2.num = temp; 
    cout << "\nAfter Swapping: " << s1.num << " " << s2.num; 
} 
   
// Driver Code 
int main() 
{ 
    // Declare and Initialize the objects of Swap class
    Swap s1(6), s2(10); 
    swap(s1,s2); 
    return 0; 
} 
===================================================================
 difference between Static Function and Friend Function:


Static Function: It is basically a member function that can be called even when the object of the class is not initialized. These functions are associated with any object and are used to maintain a single copy of the class member function across different objects of the class. This function is denoted by using the static keyword.

Friend Function: It is basically a function that is especially required for accessing non-public members of the class. It has the right to access all private and protected members of the class. It usually provides some additional functionality that is not normally used by class and allows sharing class information by non-member function.

1)It is a member function of a class that is called even when the object of the class is not initialized.	
A friend function is a non-member function or ordinary function of a class, which is declared as a friend using the keyword “friend” inside the class. 
2)In this, it cannot access any variable of its class except for static variables.
In this, it can access private and public members of the class.
3)It is denoted by placing a static keyword before the function name.
It is denoted by placing a friend keyword before the function name.
4)It can have access to members of one class.  
It can have access to members of several classes.  
5)It cannot be used when one needs to overload operators.  
It can be used when one needs to overload operations because overloading operators can only be done through friends or non-static members.  
======================================================================================
SIMPLIFYLEARNING 
TAKE NOTES FROM SIMPLIFYING LEARN FOR FRIEND FUNCTIUON
=========================================================================================

Namespace
==>Namespace provide the space where we can define or declare identifier i.e. variable,  method, classes. Namespace are necessary if you want more than one function with the same name. You can declare two different namespaces for these functions and call them by referencing their corresponding namespace. 

==>A namespace is designed to overcome this difficulty and is used as additional information to differentiate similar functions, classes, variables etc. with the same name available in different libraries. 

==>The code generally has multiple libraries, and the namespace helps in avoiding the ambiguity that may occur when two identifiers have the same name.

For example, suppose you have two functions named calculate(), and both are performing different tasks. One calculate() function is doing the multiplication, and another is doing the addition. So in this case, to avoid ambiguity, you will declare both the functions in two different namespaces. These namespaces will differentiate both the functions and also provide information regarding both the functions.

==>The best example of namespace scope is the C++ standard library (std) where all the classes, methods and templates are declared. Hence while writing a C++ program we usually include the directive using namespace std;
==============================================
Defining a Namespace:
A namespace definition begins with the keyword namespace followed by the namespace name as follows:
namespace  namespace_name 
{
    // code declarations i.e. variable  (int a;)
    method (void add();)
    classes ( class student{};)
}
It is to be noted that, there is no semicolon (;) after the closing brace.
Namespace only define them in a global scope.
It is only present in C++ and not in C.
To access a class inside a namespace, you can use namespacename::classname. 
Namespace declarations don’t have access specifiers (Public or Private).

=================================================================

C++ Namespace Example
namespace Data
{
	class Manager
	{
	public:
	void task() {}
};


You can access the class inside the above namespace in two ways:
1)by using :: operator
Data::Manager mgr;

Example:
#include <iostream>
using namespace std;
// first name space
namespace first_space
{
  void func()
  {
     cout << "Inside first_space" << endl;
  }
}
// second name space
namespace second_space
{
  void func()
  {
     cout << "Inside second_space" << endl;
  }
}
 
int main ()
{
       // Calls function from first name space.
      first_space :: func();
    // Calls function from second name space.
      second_space :: func(); 
      return 0;
}

Output
Inside first_space
Inside second_space

=======================================================================
2)By using  "using" directive 
==>You use the "using" directive to import the entire namespace into a program or another namespace. This directive eliminates the need to use the "namespace-name" every time. So it is better to use the "using" if you need several functions or classes from the namespace. Otherwise, if you only need to use it once or twice, "namespace-name" would be a better choice.
==>The using directive is positioned at the top of the program and it allows us to access all the namespace members.

using namespace Data;
Manager mgr;
mgr.task();


Example:
#include <iostream>
using namespace std;
// first name space
namespace first_space
{
  void func()
  {
     cout << "Inside first_space" << endl;
  }
}
 
// second name space
namespace second_space
{
  void func()
  {
     cout << "Inside second_space" << endl;
  }
}
using namespace first_space;
int main ()
{
   // This calls function from first name space.
  func();
  return 0;
}

Output
Inside first_space
==========================================================
// without using std namespace
std::cout
std::cin
std::endl
std::exception
std::bad_cast

By including the using namespace std; code in our program, we can omit the std:: part for the identifiers defined in the std namespace:

// using std namespace
cout
cin
endl
exception
bad_cast



===========================================================

Nested Namespaces:
Namespaces can be nested where you can define one namespace inside another name space as follows:
SYNTAX:
    namespace namespace_name1 
    {
          // code declarations
          namespace namespace_name2 
          {
             // code declarations
          }
    }

You can access members of nested namespace by using resolution operators as follows:
// to access members of namespace_name2
using namespace namespace_name1::namespace_name2;
// to access membe
rs of namespace_name1
using namespace namespace_name1;
 

==>In the above statements if you are using namespace_name1, then it will make elements of namespace_name2 available in the scope.

Example:
#include <iostream>
using namespace std;
 
// first name space
namespace first_space
{
  void func()
  {
     cout << "Inside first_space" << endl;
  }
  // second name space
  namespace second_space
  {
     void func()
     {
        cout << "Inside second_space" << endl;
     }
  }
}
using namespace first_space::second_space;
int main ()
{
    // This calls function from second name space.
      func();
   
      return 0;
}

Output
Inside second_space
=========================================================

FAQ:
FAQ:
 #include <iostream>
using namespace std;
 
// Variable created inside namespace
namespace first {
int val = 500;
}
 
// Global variable
int val = 100;
 
int main()
{
    // Local variable
    int val = 200;
 
    // These variables can be accessed from
    // outside the namespace using the scope
    // operator ::
    cout << first::val << '\n';
 
    return 0;
}

Output
500
====================================================
FAQ:
FAQ:
// A C++ program to demonstrate use of class
// in a namespace
#include<iostream>
using namespace std;
 
namespace ns
{
    // A Class in a namespace
    class geek
    {
    public:
        void display()
        {
            cout<<"ns::geek::display()"<<endl;;
        }
    };
}
 
int main()
{
    // Creating Object of geek Class
    ns::geek obj;
 
    obj.display();
 
    return 0;
}

Output
ns::geek::display()
================================================================
FAQ:
FAQ:
A class can also be declared inside namespace and defined outside namespace using the following syntax: 

CPP
   
// A C++ program to demonstrate use of class
// in a namespace
#include <iostream>
using namespace std;
 
namespace ns {
// Only declaring class here
class geek;
} // namespace ns
 
// Defining class outside
class ns::geek {
public:
    void display() { cout << "ns::geek::display()\n"; }
};
 
int main()
{
    // Creating Object of geek Class
    ns::geek obj;
    obj.display();
    return 0;
}

Output
ns::geek::display()
We can define methods as well outside the namespace. The following is an example code: 

C++
   
// A C++ code to demonstrate that we can define
// methods outside namespace.
#include <iostream>
using namespace std;
 
// Creating a namespace
namespace ns {
void display();
class geek {
public:
    void display();
};
} // namespace ns
 
// Defining methods of namespace
void ns::geek::display()
{
    cout << "ns::geek::display()\n";
}
void ns::display() { cout << "ns::display()\n"; }
 
// Driver code
int main()
{
    ns::geek obj;
    ns::display();
    obj.display();
    return 0;
}
Output:

ns::display()
ns::geek::display():
==========================================================
Standard Namespace
The std is a short form of standard, the std namespace contains the built-in classes and declared functions.
You can find all the standard types and functions in the C++ "std" namespace.

#include<iostream>
int main()
{
	std::cout<<"enter no to add";
	int num1,num2;
	std::cin>>num1;
	std::cin>>num2;
	std::cout<<"addition is"<<num1+num2;
}
Here std is used in front of cin and cout along with scope resolution operator, which indicates that the object cin and cout are defined inside the namespace whose name is std.The std is the standard library, and both cin and cout are defined inside this scope.

====================================================================
Advantage
The primary advantage of namespaces is that they resolve any naming conflict. For example, sometimes, you may need more than one function with the same name. And namespaces provide a way to declare such functions without making the compiler ambiguous. 
====================================================================
FAQ::
FAQ::

DIFFERENCE BETWEEN CLASS AND NAMESPACE
1. A namespace is a way of grouping identifiers so that they don’t clash. Using a class implies that you can create an instance of that class, not true with namespaces. 2. You can use using-declarations with namespaces, and that’s not possible with classes unless you derive from them.
3
namespace A {
int f1();
}
 
namespace A {
int f2();
}
is legal, but: 

   
class A {
    int f1();
};
 
class A { // illegal
    int f2();
};

4.
You can have unnamed namespaces but you can’t have a unnamed class.For example: 

   
namespace { // fine
 
// some code....
}
 
class { // illegal
}You can have unnamed namespaces but you can’t have a unnamed class.For example: 

   
namespace { // fine
 
// some code....
}
 
class { // illegal
}
================================================
FAQ;FAQ

Cons of using the whole namespace in C++?
Header1.h :
   
namespace one 
{ 
    /*Function to print name of the namespace*/
    void print() 
    { 
        std :: cout << "This is one" << std :: endl; 
    } 
} 
Header2.h
   
namespace two 
{ 
    /*Function to print name of the namespace*/
    void print() 
    { 
        std :: cout << "This is two" << std :: endl; 
    } 
} 
Source code file
   
/*Including headers*/
#include <iostream> 
#include "Header1.h" 
#include "Header2.h" 
  
/*Using namespaces*/
using namespace std; 
using namespace one; 
using namespace two; 
  
/*Driver code*/
int main() 
{ 
    /*Ambiguity*/
    print(); 
} 

Output:
Error: Call of overloaded print() is ambiguous.
To overcome this situation, we use namespace objects independently through scope resolution operator. Source code file
=======================================================================

operator overloading

Suppose there is a need to add two complex numbers, a function Add() can be written in the class and used as follows:
c3=c1.Add(c2);// c1,c2,c3 are the objects of complex class

==>However, it would be more natural if it is written as c1+c2.But the + operator in c++ works only for numeric built-in datatypes and c1 and c2 are user defined datatypes.As compiler doesot know the behaviour of any operator with UDTs ,if an operator is used with them,compiler gives an error.
==>To overcome such problems,c++ provides the feature of operator overloading. The '+' operator can be overloaded for a class and how to add objects can be specified.This bringd UDTs closer to built-in types.

==>operator overloading gives additional meaning to the existing operator like +,-,*,/ etc. Giving additional meaning doesnot mean a radical change,but an extension in the default behaviour of the operator. operator overloading helps the compiler to perform this type of operation when it is applied on UDTs. With the help of operator oerloading one can use the existing operators on UDTs. 

==>By using operator overloading we can add 2 userdefined datatypes also.we are giving extra task to an existing operator.
it gives additional meaning to the existing operator.this features makes UDTs more natural and close to built in datatypes.

==>the main idea behind “Operator overloading” is to use C++ operators with class variables or class objects. Redefining the meaning of operators really does not change their original meaning; instead, they have been given additional meaning along with their existing ones.

==>operator keyword is used to implement operator overloading.overloaded operators are implemented as function.An overloaded operator is called an operator function. An operator function is declared with the keyword operator preceding the operator.
ex:to overload the addition operator,a function called operator+ can be defined and implemented.


syntax:
returntype operator symbol(arg-list)
{
}
 
return_type class_name  : : operator op(argument_list)  
{  
     // body of the function.  
}  
Where the return type is the type of value returned by the function.

class_name is the name of the class.

operator op is an operator function where op is the operator being overloaded, and the operator is the keyword.


Rules and Regulations
========================================================================================
1)New operators cannot be defined or invented ..extending the meaning of the operators doesnot mean giving new meaning to the operators.
2)one cannot change the precedence or associativity of the operators.
3)one cannot change the arity of the operator.
4)we cannot overload membership operator(.),scope resolution operator(::),ternary operator,sizeof operator.
5) For operator overloading to work, at least one of the operands must be a user-defined class object.
================================================
==[]

#include<iostream>
using namespace std;
class complex
{
	int real,img;

public:
	complex();
	complex(int,int);
	void display();
	complex operator+(complex&);
	complex operator-(complex&);
	complex operator-();
	
	
};
complex::complex()
{
	real=img=0;
}
complex::complex(int real,int img)
{
	this->real=real;
	this->img=img;
}
void complex::display()
{
	if(img>0)
	cout<<"complex number is "<<real<<"+"<<img<<"i"<<endl;
	else
	cout<<"complex number is "<<real<<img<<"i"<<endl;
}
complex complex::operator+(complex & c)
{
	complex temp;
	temp.real=this->real + c.real;
	temp.img=this->img + c.img;
	return temp;
}
complex complex::operator-(complex & c)
{
	complex temp;
	temp.real=this->real - c.real;
	temp.img=this->img -c.img;
	return temp;
}
complex complex::operator-()
{
	complex temp;
	temp.real=-this->real;
	temp.img=-this->img;
	return temp;
}
 
int main()
{
	complex c1(1,2);
	complex c2(3,4);
	complex c3=c1-c2;//c1.operator-(c2)
	c3.display();
	

	complex c4(5,6);
	complex c5=-c4;//c5=c4.operator-()
	c5.display();
	
}
=================================================================================
#include<iostream>
using namespace std;
class complex
{
	int real,img;
public:
	complex(int,int);
	void display();
	
	complex operator-();
	complex operator++();
	 complex operator++(int);
	 complex();
};
complex::complex()
{
	real=img=0;
}
complex::complex(int real,int img)
{
	this->real=real;
	this->img=img;
}
void complex::display()
{
	if(img>0)
	cout<<"complex number is "<<real<<"+"<<img<<"i"<<endl;
	else
	cout<<"complex number is "<<real<<img<<"i"<<endl;
}

complex complex::operator++()//pre
{
	++this->real;//this->real=this->real + 1
	++this->img;
	return (*this);
}
complex complex::operator++(int)
{
	complex temp= (*this);
	++this->real;
	++this->img;
	return temp;
}
int main()
{
	complex c1(1,2);
	complex c2=++c1;//c2=c1.operator++()
	c1.display();
	c2.display();

	/*complex c1(1,2);
	complex c2=c1++;//c2=c1.operator++(0);
	c1.display();
	c2.display();*/

}
=================================================================
//overloading of decrement operator
#include<iostream>
using namespace std;
class complex
{
	int real,img;
public:
	complex(int,int);
	void display();
	
	complex operator-();
	complex operator--();
	 complex operator--(int);
	 complex();
};
complex::complex()
{
	real=img=0;
}
complex::complex(int real,int img)
{
	this->real=real;
	this->img=img;
}
void complex::display()
{
	if(img>0)
	cout<<"complex number is "<<real<<"+"<<img<<"i"<<endl;
	else
	cout<<"complex number is "<<real<<img<<"i"<<endl;
}

complex complex::operator--()//pre
{
	--this->real;//this->real=this->real + 1
	--this->img;
	return (*this);
}
complex complex::operator--(int)
{
	complex temp= (*this);
	--this->real;
	--this->img;
	return temp;
}
int main()
{
	complex c1(1,2);
	complex c2=--c1;//c2=c1.operator--()
	c1.display();
	c2.display();

	/*complex c1(1,2);
	complex c2=c1--;//c2=c1.operator--(0);
	c1.display();
	c2.display();*/

}
==================================================
//OVERLOADING OF = OPERATOR

==>one object can be assigned to another object provided the type of both the objects is same.
when object assignment is done,assignment operator function is called.

==>ex:
cstring s1("info");
cstring s2("tech");
s1=s2;//s1.operator=(s2) //memberwise copy

==>compiler provides a default implementation of the assignment operator for any class which performs memberwise copy of the data members. this mechanism of performing memberwise copy of the contents of the objects is called as shallow copying.
==>while performing memberwise copy,the address in the pointer data member of one object is copied into the pointer data member of another object.This means both the objects point to same memory location.it could lead to following problems:
1)Memory leakage:
2)Dangling pointer:

Therefore for classes with a pointer data member ex: class cstring,shallow copying technique cannot be used.
==>inorder to handle such memory related problems,the assignment operator needs to be overloaded.this enables deep copying
=========================================================================
==>user defined overloaded assignment operator function for the class cstring should take care of memory leakage and dangling pointer problems.steps involved in overloading the assignment operator are as follows:
1)The old buffer is deleted. ex:if object s2 is assigned to s1, first the buffer pointed by s1 is deleted.This prevents memory leakage problem.
2)Enough new memory is allocated on heap for s1.The new memory is equal to the size of buffer pointed by s2.
3)The string is copied to the newly alloacted memory .The string of s2 is copied to the newly allocated memory.
step2 and step 3 prevent the problem of dangling pointer.

==>call s1=s2 is resolved as s1.operator=(s2).
s1 is an implicit parameter which is the string to be modified. s2 is passed by reference to avoid copy constructor call.

==>
ex:
cstring s1("info");
cstring s2("tech");
s1=s2;//calls assignment operator
cstring s3=s1;//calls copy constructor

==>If a class contains atleast one data member as a pointer then to avoid memory  related problems in the applications it is necessary for the programmer to implement the following:
1)userdefined copy constructor
2)userdefined destructor
3)userdefined assignment operator

#include<iostream>
using namespace std;
#include<string.h>
class string1
{
	int len;
	char* ptr;
	public:
		void display();
		string1(char*);
		string1& operator=(string1&);
		string1(string1&)
		{
			cout<<"copy constructor is called";
		}
		
};
string1& string1::operator=(string1& s)
{
	cout<<"assignment is called\n";
	len=s.len;
	delete[] ptr;
	ptr=new char[len+1];
	strcpy(ptr,s.ptr);
	return (*this);
}
void string1::display()
{
	cout<<"length is "<<len<<endl;
	cout<<"string is "<<ptr<<endl;
}
string1::string1(char * sptr)
{
	len=strlen(sptr);
	ptr=new char[len+1];
	strcpy(ptr,sptr);
}	

int main()
{


	string1 s1("abc");
	string1 s2("xyz");
	s2=s1;//s2.operator=(s1)
	s2.display();
	

}

/*	string1 s4(s1);//give call to copy constructor
	s2.display();
	
	string1 s5=s1;//call to copy constrictor
	*/
============================================================================





#include<iostream>
using namespace std;
class complex
{
	int real,img;
public:
	complex();
	complex(int,int);
	void display();
	complex operator+(int);
	friend complex operator+(int,complex&);
};
complex::complex()
{}
complex::complex(int real,int img)
{
	this->real=real;
	this->img=img;
}
void complex::display()
{
	if(img>0)
	cout<<"complex number is "<<real<<"+"<<img<<"i"<<endl;
	else
	cout<<"complex number is "<<real<<img<<"i"<<endl;
}
complex complex::operator+(int num)
{
	complex temp;
	temp.real=real + num;
	temp.img=this->img + num;
	return temp;
}
complex operator+(int num,complex& c)
{
	complex temp;
	temp.real=c.real + num;
	temp.img=c.img + num;
	return temp;
}
int main()
{
/*	complex c1(1,2);
	complex c2=c1 + 5;//c2=c1.operator+(int)
	c2.display();//6+7i*/
	
	complex c1(1,2);
	complex c2=5+c1;// c2=5.operator+(c1) =====> c2=operator+(5,c1)            
	c2.display();
}
=========================================================================
//overloading of == operator
// C++ Program to overload == operator 
#include<iostream> 
#include<string> 
using namespace std; 
  
class Car{ 
  private: 
    string name; 
    int cost; 
    public: 
        Car(string n, int c){ 
            name=n; 
            cost=c; 
        } 
        bool operator == (const Car &c){ 
            if (name == c.name && cost == c.cost) 
                return true; 
            return false; 
        } 
}; 
int main(){ 
    Car car1 ("Santro",500000); 
    Car car2 ("Safari",1000000); 
    if (car1 == car2) 
        cout<<"Equivalent"<<endl; 
    else
        cout<<"Not Equivalent"<<endl; 
}
====================================================================
//overloading of insertion and extraction operator
In C++, stream insertion operator “<<” is used for output and extraction operator “>>” is used for input. 

1) cout is an object of ostream class and cin is an object of istream class 
2) These operators must be overloaded as a global function. And if we want to allow them to access private data members of the class, we must make them friend. 
Why these operators must be overloaded as global? 
In operator overloading, if an operator is overloaded as a member, then it must be a member of the object on the left side of the operator. For example, consider the statement “ob1 + ob2” (let ob1 and ob2 be objects of two different classes). To make this statement compile, we must overload ‘+’ in a class of ‘ob1’ or make ‘+’ a global function. 
The operators ‘<<‘ and ‘>>’ are called like ‘cout << ob1’ and ‘cin >> ob1’. So if we want to make them a member method, then they must be made members of ostream and istream classes, which is not a good option most of the time. Therefore, these operators are overloaded as global functions with two parameters, cout and object of user-defined class.
Following is a complete C++ program to demonstrate overloading of <> operators.
 

#include <iostream>
using namespace std;
 
class Complex
{
private:
    int real, imag;
public:
    Complex(int r = 0, int i =0)
    {  real = r;   imag = i; }
    friend void operator << (ostream &out, const Complex &c);
    friend void operator >> (istream &in,  Complex &c);
};
 
void operator << (ostream &out, const Complex &c)
{
    out << c.real;
    out  <<"+"<< c.imag <<"i"<< endl;
   
}
 
void operator >> (istream &in,  Complex &c)
{
    cout << "Enter Real Part ";
    in >> c.real;
    
    cout << "Enter Imaginary Part ";
    in >> c.imag;
    
}
 
int main()
{
   Complex c1;
   cin >> c1;
   cout << "The complex object is ";
   cout << c1;
   return 0;
}
==============================================================================
#include<iostream>
using namespace std;
class Date1
{
      int day;
      int month;
      int year;
      public:
             Date1(int d,int m,int y)
             {
                   day=d;
                   month=m;
                   year=y;
             }
             
             friend void operator-(Date1 &,int);
             friend void operator+(Date1 &,int);
             void display()
             {
                  cout<<"Date:"<<day<<"-"<<month<<"-"<<year<<endl;
             }
};
void operator-(Date1 &x, int y)
{
     x.day= x.day-y;
    x.month=x.month-3;
x.year=x.year-6;
 cout<<"Date:"<<x.day<<"/"<<x.month<<"/"<<x.year<<endl;
}
void  operator+(Date1 &x,int y)
{
     x.day= x.day+y;
    x.month=x.month+3;
x.year=x.year+6;
 cout<<"Date:"<<x.day<<"/"<<x.month<<"/"<<x.year<<endl;
}
int main()
{
    int dd,mm,yy;
    cout<<"Enter Day:";
    cin>>dd;
    cout<<"Enter Month:";
    cin>>mm;
    cout<<"Enter Year:";
    cin>>yy;
    
    Date1 d1(dd,mm,yy);
    d1-1;//d1=operator+(date1,int)
   	d1+2;
   
    return 0;
}
======================================================
#include<iostream>
using namespace std;
class time
{
      int hr;
      int min;
      int sec;
      public:
             time(int h,int m,int s)
             {
                   hr=h;
                   min=m;
                   sec=s;
             }
             
             friend time operator-(time &,int);
             friend time operator+(time &,int);
             void display()
             {
                  cout<<"time:"<<hr<<":"<<min<<":"<<sec<<endl;
             }
};
time operator-(time &x,int y)
{
     x.hr= x.hr-y;
     x.min= x.min-y;
     x.sec= x.sec-y;
     return x;
}
time operator+(time &x,int y)
{
     x.hr= x.hr+y;
     x.min= x.min+y;
     x.sec= x.sec+y;
     return x;
}
int main()
{
    int hr,min,sec;
    cout<<"Enter hr:";
    cin>>hr;
    cout<<"Enter Min:";
    cin>>min;
    cout<<"Enter sec:";
    cin>>sec;
    
    time t(hr,min,sec);
    t=t-1;
    t.display();
    
    return 0;
}
=============================================================
Casting Operators

Casting operators are used for type casting in C++.C++ supports four types of casts:

static_cast
dynamic_cast
const_cast
reinterpret_cast

STATIC_CAST
The static_cast operator is the most commonly used casting operator in C++. It performs compile-time type conversion .. It does things like implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions.




Syntax of static_cast
static_cast <new_type> (expression);
where,

expression: Data to be converted.
new_type: Desired type of expression

The return value of static_cast will be of new_type.

// C++ Program to demonstrate
// static_cast
#include <iostream>
using namespace std;
 
// Driver code
int main()
{
    float f = 3.5;
 
    // Implicit type case
    // float to int
    int a = f;
    cout << "The Value of a: " << a;
 
    // using static_cast for float to int
    int b = static_cast<int>(f);
    cout << "\nThe Value of b: " << b;
}

Output
The Value of a: 3
The Value of b: 3
========================================================
The behavior of static_cast for Different Scenarios
1. static_cast for primitive data type pointers:
Now let’s make a few changes to the above code.

C++
   
// C++ Program to demonstrate 
// static_cast char* to int*
#include <iostream>
using namespace std;
 
// Driver code
int main()
{
  int a = 10;
  char c = 'a';
   
  // Pass at compile time, 
  // may fail at run time
  int* q = (int*)&c;
  int* p = static_cast<int*>(&c);
  return 0;
}

Output

error: invalid 'static_cast' from type 'int*' to type 'char*'
Explanation: This means that even if you think you can somehow typecast a particular object pointer into another but it’s illegal, the static_cast will not allow you to do this.
====================================================================
3. static_cast for Inheritance in C++
static_cast can provide both upcasting and downcasting in case of inheritance. The following example demonstrates the use of static_cast in the case of upcasting.

Example:

C++
   
// C++ Program to demonstrate 
// static_cast in inheritance
#include <iostream>
using namespace std;
class Base 
{};
class Derived : public Base 
{};
 
// Driver code
int main()
{
  Derived d1;
   
  // Implicit cast allowed
  Base* b1 = (Base*)(&d1);
   
  // upcasting using static_cast
  Base* b2 = static_cast<Base*>(&d1);
  return 0;
}

Explanation: The above code will compile without any error.

We took the address of d1 and explicitly cast it into Base and stored it in b1.
We took the address of d1 and used static_cast to cast it into Base and stored it in b2.
In the above example, we inherited the base class as public. What happens when we inherit it as private? The below example demonstrate the following:

Example:

C++
   
// C++ program to demonstrate 
// static_cast in case of 
// private inheritance
#include <iostream>
using namespace std;
 
class Base 
{};
 
class Derived: private Base 
{ 
  // Inherited private/protected 
  // not public
};
 
// Driver code
int main()
{    
  Derived d1;
   
  // Implicit type cast allowed
  Base* b1 = (Base*)(&d1);
   
  // static_cast not allowed
  Base* b2 = static_cast<Base*>(&d1);
  return 0;
}

Compile-time Error:

[Error] 'Base' is an inaccessible base of 'Derived'
Explanation: The above code will not compile even if you inherit it as protected.

So to use static_cast in case of inheritance, the base class must be accessible, non virtual and unambiguous.
========================================================================================
void pointer

In C++, a void pointer is a pointer that is declared using the ‘void‘ keyword (void*). It is different from regular pointers it is used to point to data of no specified data type. It can point to any type of data so it is also called a “Generic Pointer“. 

Syntax of Void Pointer in C++
void* ptr_name;
As the type of data the void pointer is pointing to is unknown, we cannot dereference a void pointer.



============================================================================
static_cast to Cast ‘to and from’ Void Pointer
static_cast operator allows casting from any pointer type to void pointer and vice versa.

Example:

C++
   
// C++ program to demonstrate 
// static_cast to cast 'to and 
// from' the void pointer
#include <iostream>
using namespace std;
 
// Driver code
int main()
{
  int i = 10;
  void* v = static_cast<void*>(&i);
  int* ip = static_cast<int*>(v);
  cout << *ip;
  return 0;
}

Output
10
============================================================

Exception Handling

==>An exception is an unexpected problem that arises during the execution of a program our program terminates suddenly with some errors/issues. Exception occurs during the running of the program (runtime).
==>In C++, exceptions are runtime anomalies or abnormal conditions that a program encounters during its execution. The process of handling these exceptions is called exception handling.
====================================================================================
Adv of Exception handling
==>Exception Handling in C++ is a process to handle runtime errors. We perform exception handling so the normal flow of the application can be maintained even after runtime errors.
====================================================================================
==>In C++, exception is an event or object which is thrown at runtime. All exceptions are derived from std::exception class. It is a runtime error which can be handled. If we don't handle the exception, it prints exception message and terminates the program.

==========================================================================
Syntax of try-catch in C++
try {         
     // Code that might throw an exception
     throw SomeExceptionType("Error message");
 } 
catch( ExceptionName e1 )  {   
     // catch block catches the exception that is thrown from try block
 } 
1. try in C++
The try keyword represents a block of code that may throw an exception placed inside the try block. It’s followed by one or more catch blocks. If an exception occurs, try block throws that exception.

2. catch in C++
The catch statement represents a block of code that is executed when a particular exception is thrown from the try block. The code to handle the exception is written inside the catch block.

3. throw in C++
An exception in C++ can be thrown using the throw keyword. When a program encounters a throw statement, then it immediately terminates the current function and starts finding a matching catch block to handle the thrown exception.

Note: Multiple catch statements can be used to catch different type of exceptions thrown by try block.
==========================================================================================
Why do we need Exception Handling in C++?
The following are the main advantages of exception handling over traditional error handling:

1)Separation of Error Handling Code from Normal Code: There are always if-else conditions to handle errors in traditional error handling codes. These conditions and the code to handle errors get mixed up with the normal flow. This makes the code less readable and maintainable. With try/catch blocks, the code for error handling becomes separate from the normal flow.

2)Grouping of Error Types: In C++, both basic types and objects can be thrown as exceptions. 
==========================================================================================
#include <iostream> 
#include <stdexcept> // To use runtime_error 
using namespace std; 
  
// Defining function Division 
float Division(float num, float den) 
{ 
    // If denominator is Zero 
    // throw runtime_error 
    if (den == 0) { 
        throw runtime_error("Math error: Attempted to divide by Zero\n"); 
    } 
  
    // Otherwise return the result of division 
    return (num / den); 
  
} // end Division 
  
int main() 
{ 
    float numerator, denominator, result; 
    numerator = 12.5; 
    denominator = 1; 
  
    // try block calls the Division function 
    try { 
        result = Division(numerator, denominator); 
  
        // this will not print in this example 
        cout << "The quotient is "
             << result << endl; 
            string s;
            cout<<s.length();
    } 
  
    // catch block catches exception thrown 
    // by the Division function 
    catch (exception& e) { 
  
        // prints that exception has occurred 
        // calls the what function 
        // using runtime_error object 
        cout << "Exception occurred" << endl 
             << e.what(); 
    } 
  
} // end main 

==================================================================================
Object oriented concepts:

Data hiding:

==>hiding  of the data
==>our internal data should not go outside directly i..e outside person should not access our internal data directly.i.e we should hide our data..
==>ex: u have to check email.to check ur mail. by typing www.gmail.com,ur inbox mailbox wont get open.compulsory u have to provide username and password,ur gmail data is not coming outside directly,we have to do some sort of validation. after validation that data is going to come.
==>ex:ICICI bank account is der. I visit bank, and ask how much account balance, bank people ask,what is ur account number and id proof, then only bank people will provide details.
our main data should not  go directly. some sort of authentication is required then only  the data should go is called data hiding.

class Account
{
	private :
	double bal; //by implementing this bal variable as a private , we can implement data hiding
				//I want check account balance then how I will check, If u want to balance information then I will call getBal().
public:
double getBalance()
{
	//validation;
	if(valid)
	return balance;

}
//user has to call public method, within the method ,we have to perform validation,if validation succed,then only 	we can be able to provide our data.

Advantage:
whereever hiding is there, the biggest advantage is security
so my account balance ,I can only check, other people are not going to check.

======================================================================
Abstraction:


Abstraction means not complete,partially implemented, not completely provided class.
hiding internal implementation,just highlight the set of services what we are offering.
these are the set of services what I m going to offer,but how we internally implemented, plz dont ask due to security reason.
If I am exposing my internal code to any person then where is security to my code.thats why hide the internal code.

ex:If we go to At,swipe the card,enter pinnumber,which operation u want to do(withdraw,),
in this process we dont know which code is executing.
If u click withdraw button,internally how this functionality is implemented,which sql query is executing,where the database server is locating ,all this information bank people will never highlited.
bank people thru ATM gui screen,they are going to highlight the set of services what they are offering.

Ex: I want to develop java application,several services are available(withdraw,deposit),
A gui base .net application want to communicate with our java application. from.net application we have to call withdraw(), in the middle i will expose all my set of services, called as interface.
.net person has to call withdraw(),internally how this functionality is implemented we will never going to expose. because of this abstraction/interface concept two different application can communicate with each other without hightlighting our internal application. 

ADVANTAGE:
1)security because outside dont have idea internally how it is implemented

2)Enhancement:suppose withdraw() is implemented using java, I want to replace with .net functionality,internally I made changes,but gui screen is same.
without affecting enduser ,we can perform any changes in our internal code.

3)Maintainablity and modularity of the application improves because we are not hiding our internal implementation.



===============================================================
Encapsulation:

capsule: whatever the medicine require to cure cold,that medicine is going to be encapsulated. its going to be grouped into this capsule. capsule is nothing but unit, all the required things are grouped
into 1 capsule. in the same way.

ex:for every student some data members and functions are der,
the process of encapsulating or grouping of data members and corresponding behaviour into a single unit. that unit itself is called as class


int age;
int rollno;
int marks;
	+

read()
write()

student related data + behaviour

Every c++ class is an example of encapsulation.


==>if any component follows data hiding and abstraction, that component is said to be encapsulated component.
Encapsulation=data hiding + Abstraction

class Account
{
	private:
	double balance;
	public:
	public double getBal()	
	{
		//validate
		return balance;
		public void setBalance(double amt)
		{
			balance=balance + amt;
		}
	}

i will never highlight this functionalities  to outside person directly, I will provide GUI screen to the user. in that balance enq. whenever user click bal enquiry ,functionality will get executed.but enduser dont know,internally which code is executed.
==================================

				



















https://www.geeksforgeeks.org/handling-the-divide-by-zero-exception-in-c/
https://www.youtube.com/watch?v=EoRCB-Ogapo&ab_channel=funnytimegif
https://www.youtube.com/watch?v=5nCXSDv6e4I&ab_channel=PortfolioCourses










